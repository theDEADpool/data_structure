1、int socket(int family, int type, int protocol);
family：协议族，AF_INET(ipv4)、AF_INET6(ipv6)、AF_LOCAL
type：SOCK_STREAM(TCP)、SOCK_DGRAM(UDP)、SOCK_RAW(ping)
protocol：IPPROTO_TCP、IPPROTO_UDP等
函数成功时，返回非负的fd，错误返回-1。

2、int bind(int fd, const struct sockaddr* address, socklen_t address_len);
address：包含要绑定的地址和端口号。
address_len：address结构体的大小。
服务器需要调用bind，客户端可以调用bind也可以不调用。
不用bind的时候系统会自动分配一个未占用的端口。
函数成功返回0，错误返回-1。

3、int listen(int fd, int backlog);
backlog：由于TCP连接是需要三次握手的，那么在服务器上有可能存在还在握手过程中的连接，或者是刚刚握手完成但应用程序还没有来得及处理的连接。
这两种类型的连接内核会有一个队列来进行保存。backlog参数则是指定了这个队列的长度。
函数成功返回0，错误返回-1。

4、int accept(int fd, struct socketaddr* cli_addr, socklen_t* len);
cli_addr：客户端的地址。
服务器调用，函数成功时，返回非负的fd，错误返回-1。

5、int connect(int fd, const struct sockaddr *servaddr, socklen_t addrlen);
servaddr：需要连接的服务器ip和port。
函数成功返回0，错误返回-1。

6、send

7、recv

8、ssize_t sendto(int fd, const void *buf, size_t len, int flags, const struct sockaddr *to , socklen_t tolen);
用于发送UDP报文。
to：用来指定目的ip和port。
成功则返回实际发送的字符数，失败返回－1，错误原因存于errno中。

9、ssize_t recvfrom(int fd, void *buf, size_t len, int flags, const struct sockaddr *from, socklen_t fromlen);
用于接收TCP报文。
成功则返回实际接收的字符数，失败返回－1，错误原因存于errno中。

注意：sendto和recvfrom也可以用来发送和接收TCP报文。