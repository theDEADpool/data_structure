1、宏
比较大小的宏 #define MIN(x, y) ((x) < (y) ? (x) : (y))
#和##的作用
#的作用是将参数转换成字符串
#define STR(x) #x
STR(hello)展开之后为"hello"

##的作用是参数连接
#define NAME(x) name_##x
NAME(1)展开之后为name_1
如果没有##
#define NAME(x) name_x
NAME(1)展开之后为name_x

2、static关键字
修饰存储类型为静态存储类型。
静态局部变量：函数运行结束，变量值会保留，下次执行能够使用。
静态全局变量：除了上面一条之外，只能当前源文件内使用，其他文件即使使用extern也无法使用。
静态函数：只能当前源文件内使用，其他文件即使使用extern也无法使用。

3、violate关键字
强制编辑器每次都从内存中读取变量的值，而不从编辑器优化之后的寄存器中读取。
一般用于：硬件时钟、多线程中的共享变量等。

4、const关键字
const int *p 指向整形常量的指针，p的值可以改变，但*p的值不能改变。
int * const p 指向整形的常量指针，p的值不能改变，但*p的值可以改变。

5、sizeof关键字
编译阶段处理，对于数组为数组大小，对于指针4字节(32位系统)
空结构体sizeof的结果为1。
sizeof和strlen的区别：
1)sizeof是一个关键字，strlen是一个函数。
2)sizeof求得是字节长度，而strlen是实际使用长度。
3)strlen求长度是以'\0'结束的。
4)sizeof是在编译的时候计算，而strlen是在运行的时候计算。

6、字节对齐
1)结构体成员是按照#pragma pack()指定的长度和数据成员自身长度较小的那一个进行对齐。
2)结构体整体是按照#pragma pack()指定的长度和最大数据成员长度较小的那一个进行对齐。
3)包含子结构体，子结构体成员按照#pragma pack()指定的数值和子结构体最大成员长度较小的那一个进行对齐。
4)_attribute(aligned(n)),结构体成员按n字节对齐，如果成员长度大于n，则按成员长度对齐。

7、inline与宏的区别
1)内联函数在编译时展开，而宏在预编译时展开
2)在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
3)内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。
4)宏不是函数，而inline是函数
5)宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。
6)inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。
7)宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，
也就不能享受编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。

8、register关键字
register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。
register的限制
1)register变量必须是能被CPU所接受的类型。
这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。
2)因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。
3)只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。
在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。
4)局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c;
5)由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），
因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。

9、堆内存、栈内存、静态存储区
静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。
栈内存：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
栈内存是连续的内存区域，不会产生碎片。栈是由高地址向低地址方向生长。
堆内存：用户通过动态申请的内存。堆内存不是连续的内存区域，频繁的创建和删除容易产生内存碎片，使系统运行效率降低。堆是由低地址向高地址方向增长。
linux栈内存大小默认是10M，可以通过ulimit -s来设置。

10、大端序、小端序、主机序、网络序
大端序：数据的高位字节存放在地址的低端 低位字节存放在地址高端。
小断续：数据的高位字节存放在地址的高端 低位字节存放在地址低端。
比如存放 0x12345678
地址由高到低
大端序：78 56 34 12
小端序：12 34 56 78
主机序根据CPU不同可以是大端序也可以是小端序。
网络序一定是大端序。
Intel的CPU是小端序。

11、宏与const的区别
1)宏在预编译阶段展开，const常量在编译运行阶段使用。
2)宏没有类型，不会做类型检查。const变量有类型，编译阶段会做检查。
3)宏不会分配内存，只是展开。const常量会分配内存。