进程和线程
进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位
线程是进程的实体，是cpu调度和分派的基本单位，比进程更小的能独立运行的基本单位
一个进程可以有多个线程，多个线程可以并发执行

线程和进程各自区别和优劣
进程是资源分配的最小单位，线程是程序执行的最小单位。
进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。


线程同步方式
互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
信号量：允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作


进程的通信方式
主要有：管道、系统IPC（消息队列、信号量、共享内存）、SOCKET
管道是一种半双工的通信方式，数据只能单向流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程
命名管道也是半双工的通信方式，允许无亲缘关系的进程间进行通信
信号量是一个计数器，用来控制多个进程对资源的访问，通常作为一种锁机制
消息队列是消息的链表，存放在内核中，并由消息队列标识符标识
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

共享内存是映射一段能被其他进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问
---通过对这片共享空间进行写/读操作实现进城之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具(如P操作、V操作)，对共享空间的写/读进行控制。
---共享存储分为两种：基于数据结构的共享和基于存储区域的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成

SOCKET除了可以用于本机进程间通信，还可以用于不同主机上的进程间的通信

缓冲区溢出：
缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上
危害：
程序崩溃，导致拒绝服务
跳转并且执行一段恶意代码
原因：程序中没有仔细检查用户输入

死锁：两个或多个进程无限期的阻塞、相互等待的一种状态
产生条件：
互斥条件：一个资源一次只能被一个进程使用
请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

进程状态：
就绪：进程已获得除处理机以外的所需资源，等待分配处理机资源
运行：占用处理机资源运行，处于此状态的进程数小于等于CPU数
阻塞状态：进程等待某种条件，在条件满足之前无法执行

分页和分段的区别：
段是信息的逻辑单位，是根据用户的需要划分的，对用户是可见的；页是信息的物理单位，是为了管理内存的方便而划分的，对用户是透明的
段的大小不固定，由它所完成的功能决定；页大小固定，由系统决定
段向用户提供二维地址空间；页向用户提供的是一维地址空间
段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享收到限制

操作系统中进程调度策略：
FCFS（先来先服务）、优先级、时间片轮转、多级反馈

进程同步机制：
原子操作、信号量机制、自旋锁管程、会和、分布式系统

进程同步原则：
空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请
忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问
有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等
让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等

死锁基本策略：
预防、避免、检测、解除

用户态和内核态
用户态的程序不能直接操作访问操作系统内核数据结构和程序
用户态切换到内核态的三种方式：
系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个终端来实现，例如Linux的int 80h终端
异常：当CPU在执行运行在用户态下的程序时，发生了某些不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就赚到了内核态，比如缺页异常
外围设备的中断：当外围设备完成用户请求的操作后，会向cpu发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的执行时用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等


多进程编程：
创建进程，fork(）函数，调用一次返回两次
等待子进程wait(),waitpid()前者阻塞，后者支持非阻塞

信号处理机制：
信号机制是进程之间相互传递消息的一种方法，全称为软中断信号
信号用来通知进程发生了异常事件，只负责通知，并不给该进程传递任何数据

收到信号的处理方法：
指定处理函数，由该函数来处理
忽略该信号
采用系统默认处理，一般是终止

不可靠信号和可靠信号区别在于前者不支持排队，可能丢失

发送信号kill
signal系统调用，设置某个信号的处理方法
pause系统调用，等待一个信号

进程间通信编程相关：
管道：
管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失
pipe函数创建无名管道，返回读写句柄，进程分别用一端，分别关闭不用的那端
命名管道：FIFO (First in, First out)为一种特殊的文件类型，它在文件系统中有对应的路径。当一个进程以读(r)的方式打开该文件，而另一个进程以写(w)的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以FIFO实际上也由内核管理，不与硬盘打交道。之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。FIFO只是借用了文件系统(file system,命名管道是一种特殊类型的文件，因为Linux中所有事物都是文件，它在文件系统中以文件名的形式存在。)来为管道命名。写模式的进程向FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。FIFO的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接
mkfifo和mknode用来创建命名管道

信号量：
什么是信号量：信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量
工作原理：由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：
P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行
V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.
举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。
信号量机制：
创建或获取已有信号量：semget
改变信号量的值：semop
控制信号量(初始化或删除信号量)：semctl

消息队列：
什么是消息队列：消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列是随内核持续的。
每个消息队列都有一个队列头，用结构struct msg_queue来描述。队列头中包含了该消息队列的大量信息，包括消息队列键值、用户ID、组ID、消息队列中消息数目等等，甚至记录了最近对消息队列读写进程的ID。读者可以访问这些信息，也可以设置其中的某些信息。
消息队列的操作：
打开或创建消息队列
读写操作
获得或设置消息队列属性

共享内存：
什么是共享内存：共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。是针对其他通信机制运行效率较低而设计的。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。
重点：共享内存要配合同步机制使用，一般搭配互斥锁和信号量
创建共享内存：shmget
映射该地址空间到进程：shmat
解除进程对共享内存区域的映射：shmdt
操作控制共享内存区域：shmctl

套接字：
基本概念：两个基本概念：客户方和服务方。当两个应用之间需要采用SOCKET通信时，首先需要在两个应用之间（可能位于同一台机器，也可能位于不同的机器）建立SOCKET连接。
发起呼叫连接请求的一方为客户方 
在客户方呼叫连接请求之前，它必须知道服务方在哪里。所以需要知道服务方所在机器的IP地址或机器名称，如果客户方和服务方事前有一个约定就好了，这个约定就是PORT（端口号）。也就是说，客户方可以通过服务方所在机器的IP地址或机器名称和端口号唯一的确定方式来呼叫服务方。
接受呼叫连接请求的一方成为服务方。 
在客户方呼叫之前，服务方必须处于侦听状态，侦听是否有客户要求建立连接。一旦接到连接请求，服务方可以根据情况建立或拒绝连接。当客户方的消息到达服务方端口时，会自动触发一个事件（event），服务方只要接管该事件，就可以接受来自客户方的消息了。
类型：流式和数据报式，主要是TCP和UDP典型代表
基本通信流程：
服务端：socket、bind、listen、accept、receive、send、close
客户端：socket、connect、send、receive、close

线程同步机制：
互斥锁：通过锁的机制实现线程间的互斥，同一时刻只有一个线程可以锁定它，当一个锁被某个线程锁定的时候，如果有另外一个线程尝试锁定这个临界区（互斥体），则第二个线程会被阻塞，或者说被置于等待状态。只有当第一个线程释放了对临界区的锁定，第二个线程才能从阻塞状态恢复运行。
初始化：pthread_mutex_init
锁：pthread_mutex_lock
非阻塞锁：pthread_mutex_trylock
释放锁：pthread_mutex_unlock
撤销互斥锁：pthread_mutex_destroy

读写锁：读写锁与互斥量类似，不过读写锁允许更高的并行性。适用于读的次数大于写的次数的数据结构。
一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。
读锁锁住，加读锁，可以；加写锁会被阻塞，但此时会阻塞后续的读锁请求，防止读锁长期占用无法进入写模式。写锁就是互斥锁。
初始化：pthread_rwlock_init
销毁锁：pthread_rwlock_destory
加读锁：pthread_rwlock_rdlock
加写锁：pthread_rwlock_wlock
解锁:pthread_rwlock_unlock

条件变量：
互斥量只有锁住和不锁住两种状态，当条件变量和互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生
条件本身是由互斥量保护的：线程在改变条件状态之前必须先锁住互斥量
初始化条件变量：pthread_cond_init
撤销条件变量资源：pthread_cond_destory
等待条件变量(阻塞)：pthread_cond_wait
等待(根据超时时间阻塞进程)：pthread_cond_timedwait
唤醒线程：pthread_cond_signal
唤醒所有线程：pthread_cond_broadcast

自旋锁：
互斥量阻塞线程的方式是使其进入睡眠，而自旋锁是让线程忙等，即不会使其睡眠，而是不断循判断自旋锁已经被解锁。
适用于占用自旋锁时间比较短的情况。

信号量：
初始化信号量：sem_init
阻塞线程：sem_wait
增加信号量的值，唤醒线程：sem_post
释放信号量资源：sem_destory

