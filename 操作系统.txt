

线程和进程各自区别和优劣
进程是资源分配的最小单位，线程是程序执行的最小单位。
进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

线程同步方式
互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
信号量：允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作


SOCKET除了可以用于本机进程间通信，还可以用于不同主机上的进程间的通信

缓冲区溢出：
缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上
危害：
程序崩溃，导致拒绝服务
跳转并且执行一段恶意代码
原因：程序中没有仔细检查用户输入

进程同步机制：
原子操作、信号量机制、自旋锁管程、会和、分布式系统

进程同步原则：
空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请
忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问
有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等
让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等


共享内存：
什么是共享内存：共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。是针对其他通信机制运行效率较低而设计的。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。
重点：共享内存要配合同步机制使用，一般搭配互斥锁和信号量
创建共享内存：shmget
映射该地址空间到进程：shmat
解除进程对共享内存区域的映射：shmdt
操作控制共享内存区域：shmctl

线程同步机制：
互斥锁：通过锁的机制实现线程间的互斥，同一时刻只有一个线程可以锁定它，当一个锁被某个线程锁定的时候，如果有另外一个线程尝试锁定这个临界区（互斥体），则第二个线程会被阻塞，或者说被置于等待状态。
只有当第一个线程释放了对临界区的锁定，第二个线程才能从阻塞状态恢复运行。
初始化：pthread_mutex_init
锁：pthread_mutex_lock
非阻塞锁：pthread_mutex_trylock
释放锁：pthread_mutex_unlock
撤销互斥锁：pthread_mutex_destroy

读写锁：读写锁与互斥量类似，不过读写锁允许更高的并行性。适用于读的次数大于写的次数的数据结构。
一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。
读锁锁住，加读锁，可以；加写锁会被阻塞，但此时会阻塞后续的读锁请求，防止读锁长期占用无法进入写模式。写锁就是互斥锁。
初始化：pthread_rwlock_init
销毁锁：pthread_rwlock_destory
加读锁：pthread_rwlock_rdlock
加写锁：pthread_rwlock_wlock
解锁:pthread_rwlock_unlock

条件变量：
互斥量只有锁住和不锁住两种状态，当条件变量和互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生
条件本身是由互斥量保护的：线程在改变条件状态之前必须先锁住互斥量
初始化条件变量：pthread_cond_init
撤销条件变量资源：pthread_cond_destory
等待条件变量(阻塞)：pthread_cond_wait
等待(根据超时时间阻塞进程)：pthread_cond_timedwait
唤醒线程：pthread_cond_signal
唤醒所有线程：pthread_cond_broadcast

自旋锁：
互斥量阻塞线程的方式是使其进入睡眠，而自旋锁是让线程忙等，即不会使其睡眠，而是不断循判断自旋锁已经被解锁。
适用于占用自旋锁时间比较短的情况。

信号量：
初始化信号量：sem_init
阻塞线程：sem_wait
增加信号量的值，唤醒线程：sem_post
释放信号量资源：sem_destory

