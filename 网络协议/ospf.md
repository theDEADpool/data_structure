# ospf
属于IGP内部网关协议，BGP属于EGP外部网关协议；

优点：  
1. 基于SPF算法，以累计链路开销作为参考计算最短路径；  
2. 采用组播形式发送报文，减少不必要的开销；相比RIP采用广播的方式，BGP是单播；  
3. 支持区域划分；  
4. 支持等价路由进行负载分担；  
5. 支持报文认证；  

## 参考资料
https://cshihong.github.io/2017/10/19/OSPF%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/

## 基本概念
Route id：在ospf区域中唯一标识一台路由器，32位无符号整数，以ip格式来定义；比如route id是1.1.1.1，但不代表路由器就持有这个ip；  
1. 手动配置；  
2. 使用lo接口中最大的地址作为route id；  
3. 没有lo接口就用最大的ip地址作为route id；  

## 支持的网络类型
1. 广播；  
2. NBMA：非广播网络；  
3. P2MP：点到多点；  
4. P2P：点到点；  

## SPF算法
最短路径优先，也就是Dijkstra算法；  
cost：计算方式 = 100Mbps / 接口带宽，最小是1，也可以人为配置；  

## 路由器类型  
区域边界路由器ABR：用来连接AREA0和其他区域的路由器，ABR和骨干区域之间可以是物理连接，也可以是虚拟连接；  
内部路由器：每个区域内部的路由器；  
骨干路由器：至少有一个接口连接到骨干区域的路由器，所有的ABR都是骨干路由器；  
自治边界路由器ASBR：用来连接ospf的AS(自治系统)与不属于ospf区域的路由器；  

## 数据包类型
1. Hello包  
用于发现和维持邻居关系，选举DR和BDR；  
用组播的形式发送hello报文，目的地址224.0.0.5。对于NBMA网络，不能发送组播，就只能通过人工配置的方式指定邻居；  
a. network mask：hello包发送接口的掩码，用作校验，点对点网络不需要检验该掩码；  
b. hello interval：hello包发送间隔，通常是10s；  
c. route dead interval：失效时间，即时间内没有收到hello包则认为邻居失效，通常是40s；  
d. neighbor：邻居的route id列表；  
e. route priority：优先级，默认位1，用于选举DR/BDR，如果为0则表示不参与DR/BDR选举；  
f. Designated Router：DR路由器地址；  
g. Back Designated Route：BDR路由器地址；  

2、DBD包
描述本地lsdb的摘要信息，即本地有哪些LSA，接收方可以根据该信息判断自己需要哪些LSA；  
DBD包还用来确定主从关系；  
两个邻居发送的第一个DBD包都没有摘要信息，会携带一个seq和route id。比如A给B发的DBD seq = x，B给A发的DBD seq = y；  
B的route id大为主，则A给B回的DBD包seq = y，表示收到了B的DBD报文，同时会携带摘要信息；B接下来发的DBD报文seq = y + 1，也会携带摘要信息；  

3、LSR包  
链路状态请求包，路由器收到包含新内容的DBD包之后，请求更详细的信息；  

4、LSU包  
链路状态更新包，收到LSR包之后发送LSA，通告链路状态。一个LSU可能包含几个LSA。可以给其他邻居路由器发送，也可以自己以组播的方式洪泛本地LSA；  
收到LSA之后需要通过ack确认，对于没有收到的LSA重传，重传是点对点发送的；  

5、LSA包  
链路状态确认包，确认收到LSU；  
type1 路由器LSA 每个路由器都会产生，在所属的区域内传播。描述该路由器到本区域内部的链路状态和cost。边界路由器可以产生多个不同的type1 LSA；  
type2 网络LSA 由区域内DR发出，描述区域内所有链路状态信息；  
type3 网络汇总LSA 由ABR产生描述区域内所有网段的路由，通告给其他区域；  
type4 ASBR汇总LSAE 由ARB产生描述到ASBR的路由，通告给除ASBR所在区域内的其他区域；  
type5 AS外部LSA 由ASBR产生描述到AS外部的路由，通告除stub区域和NSSA区域外的所有区域；  
type7 NSSA外部LSA NSSA区域内ASBR发出，用于通告本区域连接的外部路由；  

## 三个步骤三张表
1. 建立邻居关系 -- 邻居表；
2. 形成邻接关系 -- LSDB表，保存所有的LSA信息；
3. 计算路由 -- OSPF路由表；  

## 邻居状态机
DOWN、INIT、2-WAY状态  
路由器通过hello包建立双向通信的过程。
DOWN：路由器起始状态，没有收到任何邻居的hello报文，自己会不断组播发送hello报文；  
INIT：收到了邻居的hello包，但没有自己的routeID；  
2-WAY：收到了邻居的hello包，且有自己的routeID。双向通信已建立，但还未建立邻接关系。选举DR和BDR在这个阶段完成；  

EXSTART、EXCHANGE、LOADING、FULL状态  
路由器建立完全邻接关系的过程。  
EXSTART：发送自己的空DBD报文和收到邻居的空DBD报文，确定主从关系。routeID大的路由器为主。主路由器决定DBD报文的序号；  
EXCHAGE：互相发送DBD报文同步自己的链路状态数据库；  
LOADING：发送LSR包请求链路状态的详细信息，收到邻居回复的LSU报文，发送LSAck确认收到了LSU；  
FULL：区域内所有的路由器链路状态信息达成一致；  

## 选举DR/BDR
1. 如果是点对点网络不需要选举DR/BDR，广播网络需要选举，网络类型是接口的一个属性；  
2. 选举的目的是避免区域内的路由器重复交换LSA信息；  
3. 选举之后区域内其他路由只需要与DR保持邻接关系，交换路由信息；  
4. 通过hello报文的优先级字段，优先级高的成为DR，优先级相同则route id大的称为DR；  
5. DR和BDR也是接口属性；  

## ospf区域类型  
AREA0：骨干区域，一定有，且骨干区域必须连续（虚拟链路）。其他区域必须与骨干区域相连；  
AREA1...N：子区域，区域之间的通信都要经过骨干区域；   
stub area：末梢区域，不接受自治系统以外的路由信息。该区域的ABR不允许发送Type 5类型的LSA；   
完全stub area：完全末梢区域，不接受自治系统以外以及自治系统内其他区域的路由信息。该区域的ABR除了不允许发送Type 5类型的LSA，还不允许发送type 3类型的LSA；  
NSSA：非纯末梢区域，类似与末梢区域，允许接收TYPE 7类型的LSA，并将其转换成TYPE 5类型；  
### STUB
STUB区域是一些特定的区域，STUB区域的ABR不传播它们接收到的自治系统外部路由，在这些区域中路由器的路由表规模以及路由信息传递的数量都会大大减少；  
STUB区域是一种可选的配置属性，但并不是每个区域都符合配置的条件。通常来说，STUB区域位于自治系统的边界，是那些只有一个ABR的非骨干区域；  
为保证到自治系统外的路由依旧可达，该区域的ABR将生成一条缺省路由，并发布给STUB区域中的其他非ABR路由器；  
配置STUB区域时需要注意下列几点：  
1. 骨干区域不能配置成STUB区域；  
2. 如果要将一个区域配置成STUB区域，则该区域中的所有路由器都要配置STUB区域属性；  
3. STUB区域内不能存在ASBR，即自治系统外部的路由不能在本区域内传播；  
4. 虚连接不能穿过STUB区域；  
### NSSA
NSSA（Not-So-Stubby Area）区域是OSPF特殊的区域类型。NSSA区域与STUB区域有许多相似的地方，两者都不传播来自OSPF网络其它区域的外部路由。差别在于STUB区域是不能引入外部路由，NSSA区域能够将自治域外部路由引入并传播到整个OSPF自治域中；  
当区域配置为NSSA区域后，为保证到自治系统外的路由可达，NSSA区域的ABR将生成一条缺省路由，并发布给NSSA区域中的其他路由器；  
配置NSSA区域时需要注意下列几点：  
1. 骨干区域不能配置成NSSA区域；  
2. 如果要将一个区域配置成NSSA区域，则该区域中的所有路由器都要配置NSSA区域属性；  
3. 虚连接不能穿过NSSA区域；  
7类LSA：
Type7 LSA是为了支持NSSA区域而新增的一种LSA类型，用于描述引入的外部路由信息；  
Type7 LSA由NSSA区域的自治域边界路由器（ASBR）产生，其扩散范围仅限于ASBR所在的NSSA区域；  
NSSA区域的区域边界路由器（ABR）收到Type7 LSA时，会有选择地将其转化为Type5 LSA，以便将外部路由信息通告到OSPF网络的其它区域；  
Type7 LSA转化为Type5 LSA：为了将NSSA区域引入的外部路由发布到其它区域，需要把Type7 LSA转化为Type5 LSA以便在整个OSPF网络中通告；  
P-bit（Propagate bit）用于告知转化路由器该条Type7 LSA是否需要转化；  
缺省情况下，转换路由器的是NSSA区域中Router ID最大的区域边界路由器（ABR）；  
只有P-bit置位并且FA（Forwarding Address）不为0的Type7 LSA才能转化为Type5 LSA。FA用来表示发送的某个目的地址的报文将被转发到FA所指定的地址；  
区域边界路由器产生的Type7 LSA不会置位P-bit；  

在NSSA区域中，可能同时存在多个ABR，为了防止路由环路产生，边界路由器之间不计算对方发布的缺省路由；  

## OSPF缺省路由  
缺省路由是指目的地址和掩码都是0的路由。当设备无精确匹配的路由时，就可以通过缺省路由进行报文转发。由于OSPF路由的分级管理，Type3缺省路由的优先级高于Type5或Type7路由；  
OSPF缺省路由通常应用于下面两种情况：  
1. 由区域边界路由器（ABR）发布Type3缺省Summary LSA，用来指导区域内设备进行区域之间报文的转发；  
2. 由自治系统边界路由器（ASBR）发布Type5外部缺省ASE LSA，或者Type7外部缺省NSSA LSA，用来指导自治系统（AS）内设备进行自治系统外报文的转发；  
OSPF路由器只有具有对区域外的出口时，才能够发布缺省路由LSA；  
如果OSPF路由器已经发布了缺省路由LSA，那么不再学习其它路由器发布的相同类型缺省路由。即路由计算时不再计算其它路由器发布的相同类型的缺省路由LSA，但数据库中存有对应LSA；  
外部缺省路由的发布如果要依赖于其它路由，那么被依赖的路由不能是本OSPF路由域内的路由，即不是本进程OSPF学习到的路由。因为外部缺省路由的作用是用于指导报文的域外转发，而本OSPF路由域的路由的下一跳都指向了域内，不能满足指导报文域外转发的要求；  

## 路由聚合
路由聚合是指ABR可以将具有相同前缀的路由信息聚合到一起，只发布一条路由到其它区域。区域间通过路由聚合，可以减少路由信息，从而减小路由表的规模，提高设备的性能。有两种路由聚合方式：  
1. ABR聚合  
ABR向其它区域发送路由信息时，以网段为单位生成Type3 LSA。如果该区域中存在一些连续的网段，则可以通过命令将这些连续的网段聚合成一个网段。这样ABR只发送一条聚合后的LSA，所有属于命令指定的聚合网段范围的LSA将不会再被单独发送出去；  
2. ASBR聚合  
配置路由聚合后，如果本地设备是自治系统边界路由器ASBR，将对引入的聚合地址范围内的Type5 LSA进行聚合。当配置了NSSA区域时，还要对引入的聚合地址范围内的Type7 LSA进行聚合；    
如果本地设备既是ASBR又是ABR，则对由Type7 LSA转化成的Type5 LSA进行聚合处理；  

## 路由过滤
OSPF支持使用路由策略对路由信息进行过滤。缺省情况下，OSPF不进行路由过滤。可以使用的路由策略包括route-policy，访问控制列表（access-list），地址前缀列表（prefix-list）；  
OSPF路由过滤可以应用于以下几个方面：  
1. 路由引入：OSPF可以引入其它路由协议学习到的路由。在引入时可以通过配置路由策略来过滤路由，只引入满足条件的路由；  
2. 引入路由发布：OSPF引入了路由后会向其它邻居发布引入的路由信息。可以通过配置过滤规则来过滤向邻居发布的路由信息。该过滤规则只在ASBR上配置才有效；  
3. 路由学习：通过配置过滤规则，可以设置OSPF对接收到的区域内、区域间和自治系统外部的路由进行过滤。该过滤只作用于路由表项的添加与否，即只有通过过滤的路由才被添加到本地路由表中，但所有的路由仍可以在OSPF路由表中被发布出去；  
4. 区域间LSA学习：通过命令可以在ABR上配置对进入本区域的Summary LSA进行过滤。该配置只在ABR上有效（只有ABR才能发布Summary LSA）；  
区域间LSA学习与路由学习的差异：区域间LSA学习直接对进入区域的LSA进行过滤。路由学习中的过滤不对LSA进行过滤，只针对LSA计算出来的路由是否添加本地路由表进行过滤。学习到的LSA是完整的；  
5. 区域间LSA发布：通过命令可以在ABR上配置对本区域出方向的Summary LSA进行过滤。该配置只在ABR上配置有效；  

## 快速收敛
OSPF快速收敛是为了提高路由的收敛速度而做的扩展特性。包括：  
1. OSPF按优先级收敛：在大量路由情况下，能够让某些特定的路由优先收敛的一种技术。通过对不同的路由配置不同的收敛优先级，达到重要的路由先收敛的目的，提高网络的可靠性；  
OSPF按优先级收敛能够让某些特定的路由优先收敛，因此用户可以把和关键业务相关的路由配置成相对较高的优先级，使这些路由更快的收敛，从而使关键的业务受到的影响减小；  
2. PRC（Partial Route Calculation）部分路由计算：当网络上路由发生变化的时候，只对发生变化的路由进行重新计算；  
3. 通过智能定时器控制LSA的生成与接收，达到对低频变化快速响应，又能对高频变化起到有效抑制的目的；  
在标准RFC2328协议中，通过如下两个规定来避免网络连接或者路由频繁动荡引起的过多占用设备资源的情况；  
a. 同一条LSA在1秒内不能再次生成，即LSA的更新时间间隔5秒；  
b. LSA被接收的时间间隔为1秒；  
c. 在网络相对稳定、对路由收敛时间要求较高的组网环境中，可以通过智能定时器指定LSA的更新、被接收的时间间隔为0，使得拓扑或者路由的变化可以通过LSA发布到网络中，或者立即被感知到，从而加快路由的收敛；  
4. 通过智能定时器控制路由计算：当网络发生变化时，OSPF需要重新进行路由计算，为避免这种频繁的网络变化对设备造成的冲击，标准RFC2328规定路由计算时要使用延迟定时器，定时器超时后才进行路由计算。但标准协议中，该定时器定时间隔固定，无法做到既能快速响应又能抑制振荡。通过智能定时器来控制路由计算的延迟时间，达到对低频率变化快速响应，又能对高频率变化起到有效抑制的目的。
5. OSPF Smart-discover  
通常情况下，路由器会周期性地从运行OSPF协议的接口上发送Hello报文。这个周期被称为Hello Interval，通过一个Dead Timer定时器控制Hello报文的发送。这种按固定周期发送报文的方式减缓了OSPF邻居关系的建立。通过使能Smart-discover特性，可以在特定场景下加快OSPF邻居的建立；  
a. 接口没有配置Smart-discover：必须等待Hello Timer到时才能发送Hello报文；两次报文发送间隔为Hello Interval；在这期间邻居一直在等待接收报文；  
b. 接口上配置Smart-discover：直接发送Hello报文，不需要等待Hello Timer超时；邻居可以很快收到报文迅速进行状态迁移；  
c. 在以下场景中，使能了Smart-discover特性的接口不需要等待Hello Timer到时，可以主动向邻居发送Hello报文：当邻居状态首次到达2-way状态 或 当邻居状态从2-way或更高状态迁移到Init状态；  

## Datebase Overflow（数据库超限）
OSPF协议要求同一个区域中的路由器保存相同的链路状态数据库LSDB（Link-State Database）。随着网络上路由数量不断增加，一些路由器由于系统资源有限，不能再承载如此多的路由信息，这种状态就被称为数据库超限（OSPF Database Overflow）；  
## 目的
对于路由信息不断增加导致路由器系统资源耗尽而失效的问题，可以通过配置Stub或NSSA区域来解决，但Stub或NSSA区域的方案不能解决动态路由增长导致的数据库超限问题。为了解决数据库超限引发的问题，通过设置LSDB中External LSA的最大条目数，可以动态限制链路数据库的规模；  
## 原理
通过设置路由器上非缺省外部路由数量的上限，来避免数据库超限。OSPF网络中所有路由器都必须配置相同的上限值。只要路由器上外部路由的数量达到该上限，路由器就进入Overflow状态，并同时启动超限状态定时器（默认超时时间为5秒），路由器在定时器超过5秒后自动退出超限状态；  
1. 进入Overflow状态时：路由器删除所有自己产生的非缺省外部路由；  
2. 处于Overflow状态中：不产生非缺省外部路由。丢弃新收到的非缺省外部路由，不回复确认报文。当超限状态定时器超时，检查外部路由数量是否仍然超过上限。N=>退出超限状态。Y=>重启定时器；  
3. 退出Overflow状态时：删除超限状态定时器。产生非缺省外部路由。接收新收到的非缺省外部路由，回复确认报文。准备下一次进入超限状态；  

## 邻居震荡抑制
邻居震荡抑制功能是一种震荡抑制方式，通过延迟邻居建立或调整链路开销为最大值的方法达到抑制震荡的目的；  
### 产生原因
如果承载OSPF业务的接口状态在Up和Down之间切换，就会引起邻居状态的频繁震荡。此时，OSPF会快速发送Hello报文重新建立邻居，同步数据库LSDB，触发路由计算，会造成大量报文交互，影响现有邻居的稳定性，对OSPF业务造成较大影响，同时也会影响依赖OSPF的其他业务（如：LDP、BGP）的正常运行。为了解决这个问题，OSPF实现了邻居震荡抑制功能，即在邻居频繁震荡时，启动震荡抑制，实现邻居延迟建立，或实现业务流量延迟经过频繁震荡的链路，达到抑制震荡的目的；  
### 相关概念
flapping_event：震荡事件，接口上最后一个邻居状态由Full切换为非Full，称之为flapping_event。flapping_event作为震荡源输入，用来触发震荡检测机制启动工作。
flapping_count：当前震荡次数。
detect-interval：震荡检测门限，用于判断是否触发一次有效震荡事件。
threshold：震荡抑制门限，有效震荡事件触发累计大于等于该值时，进入震荡抑制阶段。
resume-interval：震荡检测恢复门限，连续两次有效震荡事件的时间间隔大于该值时，flapping-count清0。
### 实现原理
1. 震荡检测  
OSPF接口启动一个flapping_count计数器，相邻两次flapping_event产生时间的间隔在detect-interval之内，记为一次有效震荡事件。flapping_count计数加1，当flapping_count计数大于threshold时，系统判定震荡发生，需要进入震荡抑制阶段。进入震荡抑制阶段后，flapping_count清0。在flapping_count大于threshold之前，如果两次flapping_event的间隔大于resume-interval，则flapping_count清0。邻居震荡抑制从最后一次邻居状态变为ExStart或Down开始计时；  
用户可以通过命令行配置detect-interval，threshold，resume-interval三个震荡检测的关键参数；  
2. 震荡抑制  
震荡抑制分为Hold-down和Hold-max-cost两种模式：  
a. Hold-down模式：针对邻居建立过程中的频繁泛洪和拓扑变化的问题，在一段时间内禁止该邻居重新建立，避免频繁的数据库同步和大量的报文交互；   
b. Hold-max-cost模式：针对用户业务流量频繁切换的问题，在一段时间内将链路开销值设置为最大值Max-cost（65535），避免用户的业务流量经过频繁震荡的链路；  
Hold-down模式和Hold-max-cost模式可以叠加使用，同时生效时，先进入Hold-down模式，待Hold-down模式退出后，再进入Hold-max-cost模式；  

缺省情况下，OSPF使能Hold-max-cost模式，用户可以通过命令行修改震荡抑制方案和震荡抑制周期。

说明：

接口进入震荡抑制阶段后，接口下的全部邻居都会进入震荡抑制阶段。

退出震荡抑制

退出震荡抑制有以下几种方式：

抑制定时器超时。
复位OSPF进程。
用户通过命令行强制退出震荡抑制状态。