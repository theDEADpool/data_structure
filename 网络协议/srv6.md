MPLS分两大协议LDP和RSVP-TE
LDP标签分发协议，本身没有路径计算能力，是基于IGP协议计算路径的结果，存在两个问题：
1. 设备之间需要大量的交互来维持状态；  
2. 需要同步IGP的状态否则会产生流量黑洞；  
网络中所有的设备都需要建立IGP和LDP的邻接关系，LDP依赖IGP路由信息在网络中建立MPLS的标签交换路径LSP；  
路径没有完全建立，会转发失败；路径中某个设备故障了，但LDP没有及时收敛，转发也依然会失败；  

RSVP-TE的问题
1. 配置复杂，网络中需要通过大量的交互去得知网络中其他设备的状态；  
2. 本质上是一个分布式架构，及时网络设备只知道自己的状态，想要知道网络拓扑就需要发送大量的RSVP报文来维持邻居关系，传递信息；  

SR协议
1. 基于现有协议进行扩展，集中控制和分布式转发的平衡；
2. 业务定义转发规则，数据按需转发；将网络中的段和节点，分配sid，sid有序排列就形成了一条路径；  
sid有三种：
1. node sid，为节点lo地址分配的，用来标识1个节点的，指示按照设备进行转发；  
2. adjacency sid，邻接sid，为邻接关系分配的sid，指示设备按照出接口进行转发；  
3. prefix sid，为一个网络前缀分配sid；  

如何通告sid？   
使用IGP协议通告进行拓扑信息，前缀信息，locator、sid信息。需要对报文的TLV字段进行扩展；比如ISIS；  
对于多个AS之间的通告，BGP协议有针对SRv6的扩展；  

sid可以通过IGP网络进行泛洪，网络中节点可以知道所有的sid，通过sid指导设备进行转发称为SR-BE，也可以通过多个sid的组合知道转发， 做一些流量控制，SR-TE；  
SR-BE，比如希望从a转发到d，a就给报文加上d的sid，但报文怎么去往d没有强制路径，而是根据igp计算的最短路由转发，代替LDP+IGP的方案；  
SR-TE，比如从a到d，要求经过1,2,3节点，那么就在报文前加上一个sid的list，指定1,2,3,d，报文就会按照指定好的路线进行转发；  
SR-TE里的sid可以是node sid，邻接sid，prefix sid，也可以三者混用；  
SR-TE的路径，可以是手工配置，可以是头结点根据cspf算法计算，也可以是控制器计算路径；  

SR-BE支持三种引流策略：
1. 隧道策略，根据优先级选择隧道；  
2. 配置静态路由进入隧道；  
3. 公网BGP路由通过ip进入隧道；  

SR-TE支持四种引流策略：
1. 隧道策略；  
2. 静态路由；  
3. 自动路由，把隧道当做普通路由参与IGP计算；  
4. 策略路由，将策略路由apply语句的出接口指定为隧道；  

如果转发要跨越两个SR-TE区域，SR-TE1和SR-TE2之间没有node id，需要用到BGP SR技术在两个区域之间分配sid，可以是邻接sid，也可以是邻居sid，也可以是为一组邻居分配sid；但如果转发路径很长，sid的列表也很长，浪费空间大；就可以通过bind sid解决，binding sid可以直接分配个SR-TE2这个区域，这样标签就缩短为SR-TE1内部node标签 + BGP ISD + binding SID;  

SRV6   
区别于MPLS-RS是在ip报文之外再加上标签，SRV6是复用了ipv6的扩展头部，在里面加上了SR header信息，这样除了TOR路由器，其他设备只要支持IPv6都可以进行转发；  
SR header
两个关键信息segment list + segment left， segment left是一个id指向segment list中当前活跃的成员；  
整个数据包的dst ipv6 = segment list[segment left];   
segment list是128位的ipv6地址，第一个可编程特性就体现在segment list的顺序上，可以自定segment list的顺序，按照不同的路径进行传输；  
每个segment list成员包括locator function和argument 三个部分，locator携带位置信息，function指定报文转发的指令，argument可选；  
第二个可编程特性体现在function的内容上，function根据不同的sid类型，可以指定不同的动作：  
1. End，代表一个node，对应的动作是处理SHR更新ipv6地址，然后查找路由表进行转发；  
2. End.X 代表网络中的一个邻接，对应指定是处理SRH更新ipv6地址，从SID制定的出接口转发；  
3. End.DX2：在用L2VPN或VPWS，对应解封装报文，取出SRH和IPv6头部，按照SID指定的出接口转发报文；  
4. End.DT4：PE类型的SID，主要用在IPv4 L3VPN场景，对应指令是解封装报文，取出SRH和IPv6头部，根据宝文理的目的地址，查找ipv4 VPN实例进行转发；  
5. End.DT6：主要用在IPv6 L3VPN场景，作用和上面类似；  

运营商骨干网路由器P
运营商边缘路由器PE
用户边缘路由器CE

SRv6故障保护TI-LFA FRR方案  
基本计算过程：  
1. 计算扩展P空间，以保护链路源端所有邻居为根节点建立SPF树，是所有从根节点不经过保护链路可达的节点集合；  
2. 计算Q空间，以保护链路目的端为根节点建立SPF树，是所有从根节点不经过保护链路可达的节点集合；  
3. 寻找PQ空间的交集节点，得到最短路径；  
4. 计算备份出接口，如果PQ空间没有交际，也没有直连邻居，备份出接口为收敛之后下一跳出接口；  
5. 计算repair list，由P节点标签 + PQ路径上的邻接标签组成；  

EndPoint节点故障保护  
EndPoint节点处理SRv6报文，要执行的转发行为包括SL减1，并并将下个节点的SID拷贝到外层IPv6头；如果EndPoint节点故障的时候，它无法完成报文处理。因此需要其上游节点代替完成，代替完成的节点成为Proxy forwarding节点。  
举个例子1 2 3 4，当3出现故障，2感知到后执行proxy forwarding行为，segment left--，ipv6 dst 改为4；
如果2有到4且不经过3的路由，则proxy forwarding成功；  
如果没有，则只能依赖TI-LFA计算一条不经过3的备份路径；  

尾节点保护

微防环
微环的产生，是当网络中出现故障，各节点路径收敛顺序不一致出现的一种暂时性环路；  
正切微防环即感知到故障的节点维持TI-LFA计算的备份路径转发一段时间，等待网络上其他节点完成新的路径收敛之后，其自身再更新路径；  

回切微防环，即故障路径恢复后，还是会因为收敛时间不一致导致出现的微环，而回切不会进入TI-LFA的过程，因此也无法通过延迟来解决；  
比如b c d e f，如果cd之间故障，b c之间的路径不受影响且无环，d e f之间的路径也不受影响且无环，因此故障恢复之后，只需要在指定cd之间的邻接sid，就可以保证整条链路无环；  

远端正切微防环
