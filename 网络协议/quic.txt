quic的特点

TLS1.3建连过程
1-RTT
1.client发送client hello，携带以下信息：
支持的加密算法。
支持的TLS协议版本号。
支持的椭圆曲线类型。
key_shares，根据支持的所有椭圆曲线计算出来的公钥。
2.server发送server hello，携带以下信息：
从client支持的TLS协议版本号中选择的一个版本号。
从client支持的椭圆曲线中选择的一个椭圆曲线。
根据选择的椭圆曲线生成公钥。
从这个报文开始，后面所有发送的报文都是加密的。
3.server发送Encrypted Extension(EE)报文。server hello之后需要立刻发送EE报文，这是被加密的。
4.server发送certificate报文。加密。服务端的证书链。
5.server发送certificate verify。将之前所有的报文生成认证信息发送给客户端。
6.server发送finished，表示握手结束。
7.client发送finished，表示握手结束。
握手过程中由于可能乱序或者丢包，客户端可能提前收到加密数据，而没有收到密钥。这种情况下可以选择丢弃也可以选择缓存加密数据。

0-RTT
1.client发送client hello，携带pre_shared_key、early_data等拓展。
2.client发送被加密的application data。
3.server发送server hello。携带pre_shared_key，表示自己正常解析了client发送的pre_shared_key。
4.server发送Encrypted Extension。
5.server发送finished。

1-RTT建连阶段发送的包被称作long headers。long headers包含有两个连接ID，src连接ID和dst连接ID。A给B发送报文的时候DST连接ID就是B的SRC连接ID。A的SRC连接ID就是B的DST连接ID。
第一次发包的时候A不知道B的SRC连接ID，此时A的DST连接ID是不小于8字节的任意值。在收到B的回包之前，A的DST连接ID都必须相同。
A在两种情况下会改变DST连接ID，一是收到了B的retry包，二是收到了B的initial包。
AB两端都会保存一组对端发来的连接ID。任何的连接ID都可以在发送数据时候使用。如果不需要继续使用，就通过RETIRE_CONNECTION_ID帧告诉对方。并要求对方通过NEW_CONNECTION_ID帧发送一个新的连接ID来替代旧的。

单调递增的packet number
tcp重传数据的seq num和原始数据的seq num是一样的。当收到ack的时候，无法判定是ack原始数据还是重传数据。这对于计算rtt或重传率有影响。
quic的packet number是递增的，保证重传包和原始包的num是不一样的。quic还通过stream offset来保证数据的顺序。重传包和原始包的num不一样，但是offset是一样的。

stream和conneciton级别的流量控制
connection可以理解为一个tcp连接，stream可以理解为http请求。一个connection上可以同时传输多个stream。
通过window_udpate帧告诉对方自己还可以接收的字节数。
通过block帧告诉对方流量阻塞了，不能发送数据。
stream的可用窗口大小 = 最大窗口 - 接收到数据的最大偏移量
connection的可用窗口大小 = 所有stream可用窗口相加

没有队头阻塞的多路复用
quic不同stream之间互相不会影响，某个stream丢包不会影响其他stream的数据处理。
http虽然也可以在一条tcp连接上发送多个http请求，但tcp本身就是要求有序，所以前面的包没有到达，后续的包即使到达了也不能被处理。

连接迁移
tcp是通过五元组来确定一条连接的。而quic则是通过connectionID来确定一条连接的，即使连接双方的ip发生了变化，也不会影响连接。

改进的拥塞控制
应用层实现了拥塞控制，不需要内核支持。可以根据不同的客户选择使用不同的拥塞控制算法。只需要重配置就可以完成拥塞控制算法的切换。


连接ID协商
Long header包是建联过程中发送的包，包含了source connection ID和dest connection ID。接收端到之后根据dest ID来选择连接，而将src ID设置为自己的dest ID。第一次发包的一方是不知道对方的dest ID值，这时候会填充不小于8字节的随机值。

代码结构
server部分
server结构下面conn对应的是网络socket相关的东西，比如socket读写等。要注意的是网络相关的结构conn是先于server结构创建的。先监听socket，收到了建连数据之后才创建server。
server结构下面sessionhandler管理了所有的session，是一个哈希表，connection ID为key，session结构为value。
session结构里面就包含了packer做包的封装，比如一个包包含哪些帧。还有crptoStreamhandler，加密建连的时候会用。
还有streamMap，这个就对应了quic几种流：单向发，单向收，还有双向收发。

client端跟server端整体差不多，就是在session的管理上，client端不像server端是一个哈希表。直接就是对应到具体的server。