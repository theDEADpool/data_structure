quic的特点

单调递增的packet number
tcp重传数据的seq num和原始数据的seq num是一样的。当收到ack的时候，无法判定是ack原始数据还是重传数据。这对于计算rtt或重传率有影响。
quic的packet number是递增的，保证重传包和原始包的num是不一样的。quic还通过stream offset来保证数据的顺序。重传包和原始包的num不一样，但是offset是一样的。

stream和conneciton级别的流量控制
connection可以理解为一个tcp连接，stream可以理解为http请求。一个connection上可以同时传输多个stream。
通过window_udpate帧告诉对方自己还可以接收的字节数。
通过block帧告诉对方流量阻塞了，不能发送数据。
stream的可用窗口大小 = 最大窗口 - 接收到数据的最大偏移量
connection的可用窗口大小 = 所有stream可用窗口相加

没有队头阻塞的多路复用
quic不同stream之间互相不会影响，某个stream丢包不会影响其他stream的数据处理。
http虽然也可以在一条tcp连接上发送多个http请求，但tcp本身就是要求有序，所以前面的包没有到达，后续的包即使到达了也不能被处理。

连接迁移
tcp是通过五元组来确定一条连接的。而quic则是通过connectionID来确定一条连接的，即使连接双方的ip发生了变化，也不会影响连接。

改进的拥塞控制
应用层实现了拥塞控制，不需要内核支持。可以根据不同的客户选择使用不同的拥塞控制算法。只需要重配置就可以完成拥塞控制算法的切换。

建连过程
1-RTT建连过程
1、client端发送hello报文。
2、server端发送hello报文，发送handshake报文，加密过，携带证书等相关信息。发送数据报文序号0，stream帧。
handshake报文中包含计算秘钥需要的server端生成的随机数。
3、client端发送ACK，对应server的hello报文。发送handshake报文包含FIN帧，ACK帧。对应server的handshake报文。以及数据报文序号0，stream帧。
client端收到server端发来的随机数，加上自己生成的随机数，就可以根据算法计算一个密钥。然后通过这个密钥加密报文。同时发给server端的handshake报文也会携带client端自己生成的随机数。这样server端根据这个随机数也能计算出密钥。

0-RTT建连过程
跟上面不同的是，client端在发送第一个hello报文的时候，也发送了数据报文序号0，stream帧。

连接ID协商
Long header包是建联过程中发送的包，包含了source connection ID和dest connection ID。接收端到之后根据dest ID来选择连接，而将src ID设置为自己的dest ID。第一次发包的一方是不知道对方的dest ID值，这时候会填充不小于8字节的随机值。

代码结构
server部分
server结构下面conn对应的是网络socket相关的东西，比如socket读写等。要注意的是网络相关的结构conn是先于server结构创建的。先监听socket，收到了建连数据之后才创建server。
server结构下面sessionhandler管理了所有的session，是一个哈希表，connection ID为key，session结构为value。
session结构里面就包含了packer做包的封装，比如一个包包含哪些帧。还有crptoStreamhandler，加密建连的时候会用。
还有streamMap，这个就对应了quic几种流：单向发，单向收，还有双向收发。

client端跟server端整体差不多，就是在session的管理上，client端不像server端是一个哈希表。直接就是对应到具体的server。