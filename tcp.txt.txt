三次握手：
第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

为什么要采用三次握手，两次不行吗？
假定一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。这个报文
早已失效，但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么
只要B发出确认，新的连接就建立了。
由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据，B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就
这样白白浪费了。
采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。

未连接队列
在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。
这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。

四次挥手：

客户端和服务端均可以发起

1、客户端发起、请求断开链接。发送报文FIN=1，当FIN=1的时候，表明此报文的发送方已经完成了数据的发送，没有新的数据要传送，并要求释放链接。客户端进入FIN-WAIT-1状态。

2、服务器收到客户端的请求断开链接的报文之后，返回确认信息。ACK=1，服务器进入CLOSE-WAIT状态。此时客户端不能给服务器发送信息报文，只能接收。

3、当服务器也没有了可以传的信息之后，给客户端发送请求结束的报文。FIN=1，ACK=1，服务器进入LAST-ACK状态。

4、客户端接收到FIN=1的报文之后，返回确认报文，ACK=1，发送完毕之后，客户端进入等待状态，等待两个时间周期。链接关闭。


注意：为什么要等两个时间周期

1.客户端最后一个确认收到的ACK=1的报文如果在传输的过程中丢失，服务端没有收到确认报文，就会超时重传，重新发送FIN=1的报文，如果不等两个时间周期，
重新发的FIN=1的报文客户端不会收到。
2.防止前面提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK后，再经过两个时间周期，就可以使本连接持续的时间内所产生的所有报文都
从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

为什么建立连接协议是三次握手，而关闭连接确是四次？
因为服务端的LISTEN状态下的socket当收到SYN报文的连接请求后，可以吧ACK和SYN放在同一个报文来发送。但关闭连接时，当收到对方的FIN报文
通知时，仅仅表示对方没有数据发送给你了，但是未必你的所有数据都发送给对方了，所以可能未必会马上关闭SOCKET，可能还要发送一些数据给对方
之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以关闭连接的时候FIN和ACK通常都是分开发送的。

accept发生在三次握手的哪个阶段？
三次握手完成后，客户端和服务器建立了tcp连接。这时可以调用accept函数获得此连接。



