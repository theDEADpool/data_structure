1、allocator
__malloc_alloc_template一级配置器模板，封装了malloc\realloc\free等系统调用。
支持在内存不足的情况下自定义处理函数。如果调用malloc失败，如果有自定义的处理函数，会调用该处理函数，然后再次调用malloc函数。不断循环这个过程直到申请到内存。realloc也是一样。

__default_alloc_template二级配置器模板，增加了内存对齐、轻量级内存池以及对于多线程访问内存池的处理。
对于大于128字节的内存申请交给一级配置器模板处理。对于小于128字节的内存则通过内存池分配。
申请小内存的大小会被字节对齐为8的整数倍，向上取整。
1)空闲链表的设计
_S_free_list是一个空闲内存链表的数组。数组成员个数为16，下标0的成员是一个管理0~8字节大小空闲内存的链表。下标1的成员是一个管理9~16字节大小空闲内存的链表，依次类推。最多管理128字节的内存，因为超过128字节的内存分配是通过一级配置器而不是内存池。实际上链表内的内存都是一样大的，因为分配内存的时候是8字节对齐并向上取整的。
每当有空闲内存，就根据其大小，找到对应的数组下标，从而获取对应的空闲内存链表，将空闲内存插入链表头部。Obj联合体中的_M_free_list_link字段就相当于链表节点的next。
2)内存申请的逻辑
1>根据要申请内存的大小在空闲链表里查找看是否有可用的内存，有就直接用。
2>没有空闲内存，就从内存池申请。内存池申请的内存默认是需要申请内存大小的20倍。
3>内存池剩余内存如果能够满足20倍大小要求，那么直接返回。
4>内存池剩余内存不能满足20倍大小要求，但是至少能够满足申请内存的大小，那么会根据内存池剩余的空间计算能够分配多少倍的申请内存，返回能够分配的最大整数倍内存。
5>内存池剩余内存无法满足申请内存的大小，则将内存池中剩余的内存加入到空闲链表中，然后调用系统malloc新建内存池(内存池的大小比申请内存的20倍要大)。
6>如果malloc返回失败，那么会检查空闲链表中是否存在空闲内存，如果有的话会回收到资源池，然后再次从内存池分配。
7>如果回收之后还是malloc失败，那么就只能利用一级配置器的out_of_memory机制进行处理。

1、vector
1)vector定义的时候如果没有指定大小，则大小为0。
2)push_back操作如果vector已满的情况下，vector会扩大为当前大小的两倍。如果vector大小是0，那么第一次push_back之后vector的大小是1。

