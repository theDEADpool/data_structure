1、allocator
__malloc_alloc_template一级配置器模板，封装了malloc\realloc\free等系统调用。
支持在内存不足的情况下自定义处理函数。如果调用malloc失败，如果有自定义的处理函数，会调用该处理函数，然后再次调用malloc函数。不断循环这个过程直到申请到内存。realloc也是一样。

__default_alloc_template二级配置器模板，增加了内存对齐、轻量级内存池以及对于多线程访问内存池的处理。
对于大于128字节的内存申请交给一级配置器模板处理。对于小于128字节的内存则通过内存池分配。
申请小内存的大小会被字节对齐为8的整数倍，向上取整。
1)空闲链表的设计
_S_free_list是一个空闲内存链表的数组。数组成员个数为16，下标0的成员是一个管理0~8字节大小空闲内存的链表。下标1的成员是一个管理9~16字节大小空闲内存的链表，依次类推。最多管理128字节的内存，因为超过128字节的内存分配是通过一级配置器而不是内存池。实际上链表内的内存都是一样大的，因为分配内存的时候是8字节对齐并向上取整的。
每当有空闲内存，就根据其大小，找到对应的数组下标，从而获取对应的空闲内存链表，将空闲内存插入链表头部。Obj联合体中的_M_free_list_link字段就相当于链表节点的next。
2)内存申请的逻辑
1>根据要申请内存的大小在空闲链表里查找看是否有可用的内存，有就直接用。
2>没有空闲内存，就从内存池申请。内存池申请的内存默认是需要申请内存大小的20倍。
3>内存池剩余内存如果能够满足20倍大小要求，那么直接返回。
4>内存池剩余内存不能满足20倍大小要求，但是至少能够满足申请内存的大小，那么会根据内存池剩余的空间计算能够分配多少倍的申请内存，返回能够分配的最大整数倍内存。
5>内存池剩余内存无法满足申请内存的大小，则将内存池中剩余的内存加入到空闲链表中，然后调用系统malloc新建内存池(内存池的大小比申请内存的20倍要大)。
6>如果malloc返回失败，那么会检查空闲链表中是否存在空闲内存，如果有的话会回收到资源池，然后再次从内存池分配。
7>如果回收之后还是malloc失败，那么就只能利用一级配置器的out_of_memory机制进行处理。

2、iterator
STL迭代器可以分为五类：
1)输入迭代器input_iterator：只读，且只能一次读操作，支持操作：++p,p++,!=,==,=*p,p->；
2)输出迭代器output_iterator：只写，且只能一次写操作，支持操作：++p,p++；
3)正向迭代器forward_iterator：可多次读写，支持输入输出迭代器的所有操作；
4)双向迭代器bidirectional_iterator：支持正向迭代器的所有操作，且支持操作：--p,--p；
5)随机访问迭代器random_access_iterator：除了支持双向迭代器操作外，还支持：p[n],p+n,n+p,p-n,p+=n,p-=n,p1-p2,p1<p2,p1>p2,p1>=p2,p1<=p2；

3、vector
vector使用的是随机访问迭代器。
1)vector定义的时候如果没有指定大小，则大小为0。
2)push_back操作如果vector已满的情况下，vector会扩大为当前大小的两倍。如果vector大小是0，那么第一次push_back之后vector的大小是1。

