top命令
硬中断：硬件设备（硬盘、网卡等）通知操作系统的一种方式，比如网卡收到数据。
软中断：执行中断指令产生的。
硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。
硬中断是可屏蔽的，软中断不可屏蔽。
硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。
软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。
软中断比硬中断少了一个硬件发送信号的步骤。产生软中断的进程一定是当前正在运行的进程，因此它们不会中断CPU。但是它们会中断调用代码的流程。

Swap分区在系统的物理内存不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。
那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。

10:01:23 — 当前系统时间
126 days, 14:29 — 系统已经运行了126天14小时29分钟（在这期间没有重启过）
2 users — 当前有2个用户登录系统
load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。
load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。
Tasks — 任务（进程），系统现在共有183个进程，其中处于运行中的有1个，182个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。

cpu状态
6.7% us — 用户空间占用CPU的百分比。
0.4% sy — 内核空间占用CPU的百分比。
0.0% ni — 改变过优先级的进程占用CPU的百分比
92.9% id — 空闲CPU百分比
0.0% wa — IO等待占用CPU的百分比
0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
0.0% si — 软中断（Software Interrupts）占用CPU的百分比

内存状态
8306544k total — 物理内存总量（8GB）
7775876k used — 使用中的内存总量（7.7GB）
530668k free — 空闲内存总量（530M）
79236k buffers — 缓存的内存量 （79M）

swap交换分区
2031608k total — 交换区总量（2GB）
2556k used — 使用的交换区总量（2.5M）
2029052k free — 空闲交换区总量（2GB）
4231276k cached — 缓冲的交换区总量（4GB）

第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。
纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。
如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：530668+79236+4231276 = 4.7GB。
对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。

各进程（任务）的状态监控
PID — 进程id
USER — 进程所有者
PR — 进程优先级
NI — nice值。负值表示高优先级，正值表示低优先级
VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
SHR — 共享内存大小，单位kb
S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
%CPU — 上次更新到现在的CPU时间占用百分比
%MEM — 进程使用的物理内存百分比
TIME+ — 进程使用的CPU时间总计，单位1/100秒
COMMAND — 进程名称（命令名/命令行）

core文件名携带pid
cat /etc/sysctl.conf
kernel.core_uses_pid = 1

gdb命令
bt N 显示前N个调用栈
bt -N 显示后N个调用栈
info reg 显示寄存器内容
p /x 显示十六进制数
p /o 显示八进制数
p /t 显示二进制数
p /c 显示字符
p /u 显示无符号十进制数
p /d 显示十进制数
p /s 显示字符串
p /f 显示浮点数
p /a 显示地址
watch 在变量或者语句发生变化的时候暂停执行
awatch 在变量或者语句被调用、改写的时候暂停执行
rwatch 在变量或者语句被调用的时候暂停执行
set variable 变量 = 表达式  可以认为的设置变量的值
generate-core-file 产生core文件

ps命令
进程的5种状态：R run、S sleeping、T 停止、Z 僵尸进程、D 不可中断
常用选项
-A 显示所有进程，与-e一样
-l 长格式
-f 显示完成信息
-L 显示每个进程的线程
ps aux -L | grep xxx 表示显示某一个进程的所有线程

tcpdump命令
-nn 把地址和端口显示为数值，否则显示为主机名和服务名
-P 指定抓取的包是流入包还是流出包，"in"、"out"、"inout"
-XX 输出包头数据，以16进制和ASCII两种方式同时输出，且详细输出
-c 指定抓包的个数
-w 将装包的内容输出到指定文件
-i 指定抓哪个网口
-v 输出详细的报文信息
-vv 输出更详细的报文信息
src 源地址
dst 目的地址
src port
dst port
host 指定主机或者目的地址
tcpdump src host [ip/hostname] dst host [ip/hostname] tcp/udp port [xxx]

strace
-tt 每行输出之前显示时间，单位毫秒。
-T 每次系统调用花费的时间。
-f 跟踪目标进程及其创建的所有子进程。
-e 指定要跟踪的系统调用名称
-o 把结果输出到指定的文件
-p 指定跟踪的进程，如果要指定多个进程就写多个-p
-s 当系统调用某个参数是字符串的时候输出指定长度的内容，默认是32个字节
命令格式：
跟踪未启动的进程: strace [各类选项] [启动进程的命令，比如/usr/bin/nginx]
跟踪已启动的进程：strace [各类选项] -p 进程号

CPU跑满排查-->一般情况下就是死循环
top命令可以找到CPU跑满的进程。顺便可以检查内存使用量是否正常。
top -H -p pid 查看某个进程的线程情况。
ps命令可以找到某个进程和其线程的CPU使用情况 -T选项可以查看线程。
pstack命令则可以看到某个线程的调用栈信息，pstack [进程号]
strace可以查看程序运行过程中的系统调用。

内存检测工具
addressSanitizer 检查内存越界访问
基本原理就是替换操作系统的malloc和free函数，在申请内存时候在内存周围填充一些特殊字节，在程序释放内存的时候，填充了特殊字节的内存会暂时保留。然后在程序运行的过程中检查填充了特殊字节的内存是否被修改。
需要gcc4.8版本及以上的编译器或者clang。编译的时候带上参数CFLAG='-g-O0-fsnitize=address-fno-omit-frame-pointer-lasan'
设置环境变量export ASAN_OPTIONS="log_path=/tmp/asan.log"
把环境变量加到程序的启动脚本里面才能生效，/etc/init.d/xxxx

valgrind
