1.defer先定义后执行。defer是在调用函数运行结束之后再执行，执行的时候仍然可以访问调用函数中定义的变量。

2.channel分为只读channel、只写channel和可读可写channel。channel需要通过make来分配长度，否则不能使用。
使用for + range来循环管道之前，管道需要调用close关闭。否则会出现deadlock。

3.不带缓冲区的channel，只能存1个数据，而且只有当存的数据被取出之后，才能存下一个数据，否则会阻塞。
带缓冲区的channel，可以保存多个数据。
只读只写的channel一般用于函数的入参或者返回值，规定channel在函数内部是只读还是只写的属性。
读写channel的时候可以通过time.Tick来控制channel读写的频率。

4.select与channel配合使用，用于等待一个或者多个channel输出。
如果有一个case满足，则执行满足的case。
如果有多个case满足，则随机执行一个case。
如果没有case满足，select会阻塞。如果不想让select阻塞，则可以设置default。没有case满足的时候，select会执行default，执行完成后退出。此时需要用一个for循环来不断的调用select，监听是否有case满足。

5.struct结构体之间能不能比较
如果结构体所有的成员变量都可以比较，那么结构体可以比较。
如果结构体有不可比较的成员变量，那么结构体不可比较。slice、map都不可比较。
结构体之间进行转换要求结构体本身要有相同的字段名、字段类型、字段个数。
因此只有可比较的struct才能作为map的key。

6.context用于多个goroutine之间传递上下文信息，目的是实现并发控制，超时控制。
用法main函数调用context.Background创建一个根context。根context不能取消，不会超时，也没有值。
goroutine在根context的基础之上调用withCancel方法创建一个可以取消的contex。
每一级context都有个map结构，用来保存由它所创建的子goroutine中的context。
withCancel方法还会返回一个取消函数。当取消函数被调用的时候，会遍历上面说的map结构，对每个子contenxt都执行cancel操作。同时将自身从父context的map中删除。
如果父context超时，那么子context也会超时。不需要单独处理子context超时。
context作为参数传给函数，但不要传nil，如果没有可以传入的实参，那么就传入context.TODO

7.基于数组/slice创建一个新slice的时候，新slice和原数组/slice指向的底层数组是同一个。
slice作为参数传递的是副本，但对应的数组是同一个。
slice扩容的时候会变为原来容量的2倍。如果原slice长度大于等于1024，那么每次扩容为原容量的1.25倍。

8.go语言调度器
G：代表创建的一个个gorouting协程
P：代表处理器，P的数量通过GOMAXPROCS设置。一般设置为CPU的最大核数。
M：代表系统线程
P管理一个G的队列，M得到P之后，P就可以执行队列中的每个G。当M因为G调用系统调用进入内核态之前，go调度器创建一个新的线程将当前的P交给新的M，从而保证P队列中的G能够继续调度，而不会因为M进入内核态而阻塞。当G的系统调用完成回到用户态时，旧M因为没有P所以不能继续执行G。因此只能将G加入全局队列中等待调度。M本身要么退出要么进入线程池。
当P将队列中的G都执行完成之后，就会从全局队列中取出G来执行。同时也会定期检查全局队列中的G，确保队列中的G能够得到调度而不是一直等待。实际上go语言并非每次M因为系统调用进入内核态就创建一个新的M，而是监视进入内核态的M，只有时间过长才会创建新的M。
如果P的G队列已经执行完了，全局队列也为空，那么此时P所对应的M会从其他M管理的P中获取一半的G来执行，避免无效的等待。

9.go语言垃圾回收
当前goroutine的栈和全局数据区称为root区。从该区开始扫描，标记root区域的指针为可达，然后再根据每个指针递归标记所有可达的对象。
为了保证在标记的过程中代码仍然能够正常的执行，采用三色标记法。
开始所有对象都是白色，扫描过后变成灰色，放入待处理队列。
从队列中取出每个灰色的对象，然后将其引用的所有对象标记为灰色加入队列，并将其自身标记为黑色。
写屏障检控内存修改，编译器在每次内存写操作之前生成一小段代码来完成重新标色。
完成标色的对象不是白色就是黑色，白色的就是要回收的对象。
对于go来说，标记且在队列中的就是灰色，标记但不在队列中是黑色，没有标记的是白色。标记过程是多个gorouting同时进行的。

10.new和make
new只有一个参数，是一个类型。返回的是指向这个类型的指针。
make只用于chan、map和slice的内存创建。有两个入参，一个是类型，一个是创建对象的大小。返回的是对象的引用。

11.init函数
包级别定义。go程序导入的包需要被初始化，先初始化包级别声明的变量，然后执行init函数。init函数仅执行一次。
如果需要执行包的init函数，但是又不会用到包中的任何方法或者变量，这种情况如果直接import 包是会提示没有使用的错误。可以使用import _ 包
每个包都可以有一个或者多个init函数。如果一个包包含多个源文件，那么init函数执行顺序默认是按照文件名排序的。
不同的包init函数执行顺序与包导入的顺序是一致的。不论一个包被导入多少次，其init函数只执行一次。