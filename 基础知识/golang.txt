1.defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;
defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露。
多个 defer 调用顺序是 LIFO（后入先出），defer后的操作可以理解为压入栈中
defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。defer可以修改函数最终返回值，
修改时机：有名返回值或者函数返回指针；

2.channel分为只读channel、只写channel和可读可写channel。channel需要通过make来分配长度，否则不能使用。
使用for + range来循环管道之前，管道需要调用close关闭。否则会出现deadlock。

3.不带缓冲区的channel，只能存1个数据，而且只有当存的数据被取出之后，才能存下一个数据，否则会阻塞。
带缓冲区的channel，可以保存多个数据。
只读只写的channel一般用于函数的入参或者返回值，规定channel在函数内部是只读还是只写的属性。
读写channel的时候可以通过time.Tick来控制channel读写的频率。

4.select与channel配合使用，用于等待一个或者多个channel输出。
如果有一个case满足，则执行满足的case。
如果有多个case满足，则随机执行一个case。
如果没有case满足，select会阻塞。如果不想让select阻塞，则可以设置default。没有case满足的时候，select会执行default，执行完成后退出。
此时需要用一个for循环来不断的调用select，监听是否有case满足。

select 的特性
1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。
2）select 仅支持管道，而且是单协程操作。
3）每个 case 语句仅能处理一个管道，要么读要么写。
4）多个 case 语句的执行顺序是随机的。
5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。

5.struct结构体之间能不能比较
如果结构体所有的成员变量都可以比较，那么结构体可以比较。
如果结构体有不可比较的成员变量，那么结构体不可比较。slice、map都不可比较。
结构体之间进行转换要求结构体本身要有相同的字段名、字段类型、字段个数。
因此只有可比较的struct才能作为map的key。

6.context用于多个goroutine之间传递上下文信息，目的是实现并发控制，超时控制。
用法main函数调用context.Background创建一个根context。根context不能取消，不会超时，也没有值。
goroutine在根context的基础之上调用withCancel方法创建一个可以取消的contex。
每一级context都有个map结构，用来保存由它所创建的子goroutine中的context。
withCancel方法还会返回一个取消函数。当取消函数被调用的时候，会遍历上面说的map结构，对每个子contenxt都执行cancel操作。同时将自身从父context的map中删除。
如果父context超时，那么子context也会超时。不需要单独处理子context超时。
context作为参数传给函数，但不要传nil，如果没有可以传入的实参，那么就传入context.TODO

7.基于数组/slice创建一个新slice的时候，新slice和原数组/slice指向的底层数组是同一个。
slice作为参数传递的是副本，但对应的数组是同一个。
slice扩容的时候会变为原来容量的2倍。如果原slice长度大于等于1024，那么每次扩容为原容量的1.25倍。

8.go语言调度器
G：代表创建的一个个gorouting协程
P：代表处理器，P的数量通过GOMAXPROCS设置。一般设置为CPU的最大核数。
M：代表系统线程
P管理一个G的队列，M得到P之后，P就可以执行队列中的每个G。当M因为G调用系统调用进入内核态之前，go调度器创建一个新的线程将当前的P交给新的M，从而保证P队列中的G能够继续调度，而不会因为M进入内核态而阻塞。当G的系统调用完成回到用户态时，旧M因为没有P所以不能继续执行G。因此只能将G加入全局队列中等待调度。M本身要么退出要么进入线程池。
当P将队列中的G都执行完成之后，就会从全局队列中取出G来执行。同时也会定期检查全局队列中的G，确保队列中的G能够得到调度而不是一直等待。实际上go语言并非每次M因为系统调用进入内核态就创建一个新的M，而是监视进入内核态的M，只有时间过长才会创建新的M。
如果P的G队列已经执行完了，全局队列也为空，那么此时P所对应的M会从其他M管理的P中获取一半的G来执行，避免无效的等待。

9.go语言垃圾回收
当前goroutine的栈和全局数据区称为root区。从该区开始扫描，标记root区域的指针为可达，然后再根据每个指针递归标记所有可达的对象。
为了保证在标记的过程中代码仍然能够正常的执行，采用三色标记法。
开始所有对象都是白色，扫描过后变成灰色，放入待处理队列。
从队列中取出每个灰色的对象，然后将其引用的所有对象标记为灰色加入队列，并将其自身标记为黑色。
写屏障检控内存修改，编译器在每次内存写操作之前生成一小段代码来完成重新标色。
完成标色的对象不是白色就是黑色，白色的就是要回收的对象。
对于go来说，标记且在队列中的就是灰色，标记但不在队列中是黑色，没有标记的是白色。标记过程是多个gorouting同时进行的。

10.new和make
共同点：给变量分配内存
不同点：
1）作用变量类型不同，new给string,int和数组分配内存，make给切片，map，channel分配内存；
2）返回类型不一样，new返回指向变量的指针，make返回变量本身；
3）new 分配的空间被清零。make 分配空间后，会进行初始化；

11.init函数
包级别定义。go程序导入的包需要被初始化，先初始化包级别声明的变量，然后执行init函数。init函数仅执行一次。
如果需要执行包的init函数，但是又不会用到包中的任何方法或者变量，这种情况如果直接import 包是会提示没有使用的错误。可以使用import _ 包
每个包都可以有一个或者多个init函数。如果一个包包含多个源文件，那么init函数执行顺序默认是按照文件名排序的。
不同的包init函数执行顺序与包导入的顺序是一致的。不论一个包被导入多少次，其init函数只执行一次。

12.map
1）map不是并发安全，map无序；
2）使用map一定要make，否则panic
3）map删除一个key内存是否会释放？如果key对应的val是int、bool、float、string、数组、结构体等不会释放，如果对应的是指针、slice、map、chan等会释放；

13.数组和切片有什么区别
相同点：
1)只能存储一组相同类型的数据结构；
2)都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取；
3)函数传递中两者都是值传递；
区别：
1）数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容；
2）数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，
所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变；

Go 的 slice 底层数据结构是由一个 array 指针指向底层数组，len 表示切片长度，cap 表示切片容量。slice 的主要实现是扩容。
对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，
则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。
对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），
避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），
采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，
那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。

（关于刚才问的 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，
则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，
则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice。）

14. panic和recover是Go语言中用于处理异常的机制。当程序遇到无法处理的错误时，可以使用panic引发一个异常，中断程序的正常执行。
而recover用于捕获并处理panic引发的异常，使程序能够继续执行。

15.多协程间如何保证并发安全：锁、原子操作、channel。