1、宏
比较大小的宏 #define MIN(x, y) ((x) < (y) ? (x) : (y))
#和##的作用
#的作用是将参数转换成字符串
#define STR(x) #x
STR(hello)展开之后为"hello"

##的作用是参数连接
#define NAME(x) name_##x
NAME(1)展开之后为name_1
如果没有##
#define NAME(x) name_x
NAME(1)展开之后为name_x

extern关键字
1)extern "C"表示用C语言的规则来编译某个函数。
2)extern修饰变量或者函数，其他文件可以使用该变量或者函数。
3)如果某个变量是定义在头文件中的，即声明的时候做了初始化。同时又有多个文件需要使用该变量，不能通过包含头文件的方式，这样在编译过程中会报错。只能在需要使用该变量的文件中通过extern声明该变量。

2、static关键字
修饰存储类型为静态存储类型。
静态局部变量：函数运行结束，变量值会保留，下次执行能够使用。
静态全局变量：除了上面一条之外，只能当前源文件内使用，其他文件即使使用extern也无法使用。
静态函数：只能当前源文件内使用，其他文件即使使用extern也无法使用。
局部变量变为静态变量是改变了其存储区域从而改变了其生命周期。全局变量变为静态变量则是改变了其作用域，限制了其作用范围。
静态成员变量：不论创建多少个类实例，静态成员都只有一个副本。静态成员的初始化不能放在类定义中，需要单独声明。
静态成员函数：不需要类实例就可以调用。但静态成员函数只能访问静态成员变量、其他静态成员函数和类外部函数。而且静态成员函数没有this指针。

3、violate关键字
强制编辑器每次都从内存中读取变量的值，而不从编辑器优化之后的寄存器中读取。
一般用于：硬件时钟、多线程中的共享变量等。

4、const关键字
const int* p 指向整形常量的指针，p的值可以改变，但*p的值不能改变。
int* const p 指向整形的常量指针，p的值不能改变，但*p的值可以改变。
const修饰的对象，只能使用类中const成员函数，非const对象可以使用类中所有的成员函数。const对象可以使用类中所有成员变量，但不可修改任意成员变量。
const成员函数只能访问不能修改对象的成员变量，但可以修改被mutable修饰的成员变量。该特点也适用于const对象。mutable不可以修饰const类型的成员变量。
非const成员函数可以访问非const对象的非const成员变量和const成员变量，但是不能访问const对象的任意成员变量。
如果成员函数不对成员变量进行修改操作，应该尽量声明为const成员函数。
类中的const成员变量几种赋值方式：
1)在声明类的时候赋值，只在c++11后支持。
2)在类构造函数后面的初始化参数列表中赋值，如类A中a1是const int成员变量，A::A():a1(123){...}。需要注意的是初始化参数列表只能写在构造函数定义的地方，不能写在构造函数声明的地方。
3)给const成员加上static关键字，这样可以直接在类外部赋值，如const int A::a1 = 123。
假设类A有一个成员函数void funcA();,该成员函数重载了void funcA() const;，那么对于A a; a.funcA();会调用非const类型的成员函数，而const A a; a.funcA();则会调用const类型的成员函数。

5、sizeof关键字
编译阶段处理，对于数组为数组大小，对于指针4字节(32位系统)、8字节(64位系统)
空结构体和空类sizeof的结果为1。	
sizeof和strlen的区别：
1)sizeof是一个关键字，strlen是一个函数。
2)sizeof求得是字节长度，而strlen是实际使用长度。
3)strlen求长度是以'\0'结束的。
4)sizeof是在编译的时候计算，而strlen是在运行的时候计算。

6、字节对齐
1)结构体成员是按照#pragma pack()指定的长度和数据成员自身长度较小的那一个进行对齐。
2)结构体整体是按照#pragma pack()指定的长度和最大数据成员长度较小的那一个进行对齐。
3)包含子结构体，子结构体成员按照#pragma pack()指定的数值和子结构体最大成员长度较小的那一个进行对齐。
4)_attribute(aligned(n)),结构体成员按n字节对齐，如果成员长度大于n，则按成员长度对齐。

7、inline与宏的区别
1)内联函数在编译时展开，而宏在预编译时展开
2)在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
3)内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。
4)宏不是函数，而inline是函数
5)宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。
6)inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。
7)宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，
也就不能享受编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。

8、register关键字
register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。
register的限制
1)register变量必须是能被CPU所接受的类型。
这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。
2)因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。
3)只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。
在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。
4)局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c;
5)由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），
因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。

9、堆内存、栈内存、静态存储区
静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。
栈内存：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
栈内存是连续的内存区域，不会产生碎片。栈是由高地址向低地址方向生长。
堆内存：用户通过动态申请的内存。堆内存不是连续的内存区域，频繁的创建和删除容易产生内存碎片，使系统运行效率降低。堆是由低地址向高地址方向增长。
linux栈内存大小默认是10M，可以通过ulimit -s来设置。

10、大端序、小端序、主机序、网络序
大端序：数据的高位字节存放在地址的低端 低位字节存放在地址高端。
小断续：数据的高位字节存放在地址的高端 低位字节存放在地址低端。
比如存放 0x12345678
地址由高到低
大端序：78 56 34 12
小端序：12 34 56 78
主机序根据CPU不同可以是大端序也可以是小端序。
网络序一定是大端序。
Intel的CPU是小端序。

11、宏与const的区别
1)宏在预编译阶段展开，const常量在编译运行阶段使用。
2)宏没有类型，不会做类型检查。const变量有类型，编译阶段会做检查。
3)宏不会分配内存，只是展开。const常量会分配内存。

12、拷贝构造函数
拷贝构造必须的参数是本类型的一个引用变量。
class CExample
{
public:
    //构造函数
    CExample(int b)
    {
        a=b;
        printf("constructor is called\n");
    }
    //拷贝构造函数
    CExample(const CExample & c)
    {
        a=c.a;
        printf("copy constructor is called\n");
    }
    //析构函数
    ~CExample()
    {
        cout<<"destructor is called\n";
    }
};
调用时机：
1)类对象作为函数参数。
2)类对象作为函数返回值。
3)类对象通过另外一个类对象来初始化。

13、浅拷贝、深拷贝
浅拷贝只是对类成员变量进行简单的复制操作。那么对于指针类型的成员变量会出现问题。
假设类实例a.p = new int(1);，类实例b = a;，b.p的值也是1，但实际上b.p和a.p是指向同一块内存。
深拷贝则是对于类动态成员变量进行重新分配内存的操作。
C++默认的拷贝构造函数是浅拷贝模式。因此对于有动态成员的类，构造函数需要自定义一个深拷贝的拷贝构造函数。

14、重载overload、覆盖override、重写overwrite
overload：同一个类当中，函数名相同， 参数不同(类型不同或者数量不同，或者两者都不同)。不以返回值类型作为重载的判断条件。
override：父类和子类中，子类实现父类中的虚函数。
overwrite：父类和子类中，子类实现父类中的非虚函数。

15、抽象类：含有纯虚函数的类。抽象类不能直接生成对象。
接口类：仅含有纯虚函数的类。
聚合类；用户可以直接访问其成员，且具有特殊的初始化语法形式。
1)所有成员都是public。
2)没有定义任何构造函数。
3)没有类内初始化。
4)没有基类，也没有virtual函数。
聚合类的缺点：所有成员都是public，有用户自行初始化成员容易出错，添加或删除成员后所有的初始化语句都要更新。

17、重载确定的步骤
1)确定候选函数，候选函数需要与被调函数同名，且在调用处其声明可见。
2)选择可行函数，可行函数需要与调用函数参数个数相同。且每个实参类型都能对应匹配或可允许隐式转换。
3)寻找最佳匹配，如果某一个函数其每个实参的匹配都不劣于其他可行函数的匹配，或某一个函数其至少有一个参数的匹配由于其他可行函数提供的匹配。则该函数为最佳匹配函数。

19、基类先与派生类被初始化。一个类中的成员变量的初始化顺序与其声明时成员变量的顺序是一致的，与构造函数中成员变量初始化的顺序无关。
类成员变量在构造函数中采用成员初始化列表的方式来进行初始化。这个对于const成员变量很有用。
如类A，构造函数A::A(const int i, const int j):a1(i),a2(j){};

20、编译器会为一个类创建默认的构造函数、拷贝构造函数、赋值操作符函数和一个析构函数，如果类本身没有声明这些函数。
如果一个类禁止拷贝操作，就将拷贝构造函数和赋值操作符函数声明为private，且只声明不实现。这样，即可以避免编译器生成默认的拷贝构造函数和赋值操作符函数，也可以防止成员函数和友元函数调用拷贝构造函数和赋值操作符函数。

21、继承
1、创建一个派生类的对象时，基类的构造函数会先于派生类的构造函数执行。如果基类的构造函数有调用虚函数，只会执行基类实现的虚函数，不会执行派生类对于虚函数的实现。
2、基类的引用或指针可以指向一个派生类的对象。
3、自定义派生类的构造函数时，除了要初始化派生类的成员变量，还需要调用基类的构造函数，初始化基类的成员变量。
4、虚继承
虚继承用来解决C++菱形继承问题。在菱形继承的情况下，派生类中会有最上层基类的多份拷贝。一来浪费内存空间，二来如果使用最上层基类的指针指向派生类对象时，会出现二义性。因为多份拷贝的问题，基类指针无法确定应该使用哪一份拷贝。
虚继承在派生类中会有一个指针指向虚基类表，其中记录了子类相对于虚基类的偏移量。派生类对象在构造时，虚基类的构造函数只会调用一次。

22、智能指针
1)解决内存泄漏问题。
2)解决空悬指针(野指针)问题。
3)解决由于抛出异常后可能引起的内存泄漏问题。

auto_ptr，在C++11中已被弃用，有以下特点：
1>auto_ptr赋值给另外一个auto_ptr之后，对象的所有权会发生转移。如auto_ptr p2 = p1;此时p2指向p1所指向的对象，而p1则会指向空的对象。
2>auto_ptr不能作为函数的返回值和函数参数，也不能在容器中保存auto_ptr。
为什么auto_ptr不能作为vector成员类型？
STL的容器要对能够对对象进行安全的赋值操作，拷贝之后原对象不会改变。而auto_ptr拷贝之后原指针会被设定指向NULL。比如vector < auto_ptr <int> > vp; auto_ptr <int> vp1 = vp[0]; 如果这段代码是可以编译运行的，那么vp[0]在赋值之后会变成NULL。这显然是不能被允许的。

C++11之后智能指针分为shared_ptr、unique_ptr、weak_ptr。
uique_ptr独占指针，指针对象的生命周期与其一致。
shared_ptr共享指针，多个shared_ptr可以指向相同的对象。当最后一个shared_ptr生命周期结束时，所指向的对象会被释放。
weak_ptr作为shared_ptr的辅助指针，不能决定其所指对象的生命周期。需要lock成shared_ptr才能引用其所指对象。
智能指针的构造函数都有explicit关键字修饰，不支持隐式转换如shared_ptr<int> sp = new int(100);这种写法会报错。要写成shared_ptr<int> sp(new int(100));
或者写成shared_ptr<int> sp = make_shared<int>(100);应该更多的使用make_shared方法来创建一个只能指针。

1)shared_ptr有引用计数。用shared_ptr初始化另一个shared_ptr、作为函数入参、作为函数返回值，其引用计数就会递增。shared_ptr赋予一个新值、share_ptr离开作用域则引用计数会递减。当引用计数为0，则会释放其管理的对象。
shared_ptr<int> sp = p; //会让p的引用计数+1
sp = q; //q的引用计数+1，sp之前指向的对象引用计数-1，如果减为0则自动释放。
sp.reset(new int(1024)); //sp重新指向一个新的对象，原对象的引用计数-1。
shared_ptr默认调用delete来释放内存，如果shared_ptr指向数组，那么需要在创建智能指针的时候指定删除器。
shared_ptr<int> p(new int[10], [](int *p){ delete []p; });

2)unique_ptr是独享所有权的指针，无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作。保存指向某个对象的指针，当它本身被释放，指向的对象也会被释放。
unique_ptr<int> up1(new int(100));
unique_ptr<int> up2(new int(50));
up2 = move(up1); //不能直接up2 = up1
up2.reset() //释放up2所指向的对象，并将up2设为null。
up1.release() //release()本身只是转移控制权，没有释放内存，因此这个写法会造成内存泄漏。正确的写法为unique_ptr<int> up3(up1.release());

3)weak_ptr是为了防止shared_ptr相互引用时，引用计数永远不会下降为0，而导致资源无法释放。weak_ptr不会增加对象的引用计数。
创建weak_ptr需要shared_ptr来初始化。weak_ptr<int> wp(sp);
不能直接访问weak_ptr所指向的对象，需要通过lock()，如果wp所指向的对象存在，lock(wp)会返回一个shared_ptr，如果wp所指向的对象已经被释放，那么lock(wp)会返回一个空的shared_ptr。
wp.expire()返回true或false来表示对象是否已经释放。

智能指针的注意事项：
1)不能将一个原生指针交给多个shared_ptr或者unique_ptr管理。
int *p = new int;
shared_ptr<int> sp1(p);
shared_ptr<int> sp2{p);
当sp1和sp2生命周期结束时，p指向的内存会被释放两次。
2)不能将this指针交给智能指针管理，原因同上，也是会存在内存释放两次的问题。
3)不是new得到的内存，需要自定义删除器。
4)尽量不要使用get()。特别是通过get()来初始化其他的智能指针，或者直接释放get()返回的原生指针。
5)使用shared_ptr时要避免循环引用。

23、多态的实现
多态是指不同的对象接收相同的消息产生不同的结果。
重载多态(编译期)：函数重载、运算符重载
子类型多态(运行期)：虚函数
参数型多态(编译期)：类模板、函数模板
强制多态(编译期/运行期)：基本类型转换、自定义类型转换

模板又分为函数模板和类模板。在编译期根据模板和实际的参数类型对模板进行实例化。
函数模板可以定义为inline或constexpr。普通函数可以定义模板，成员函数也可以定义为模板，但成员函数模板不能是虚函数。

2)虚函数
1>static成员函数不能是虚函数。
2>构造函数不能是虚函数。因为在调用构造函数的时候指向虚函数表的指针还没有创建，只有构造完成才会创建。
3>inline可以用来修饰虚函数，但当虚函数表现出多态性时不能内联。通俗来说就是inline修饰虚函数编译不会报错，但并不会在编译阶段进行展开。因为虚函数本来就是用来实现多态的，多态是在运行阶段才能确定的。而inline却是在编译阶段进行展开的。两者有冲突。
4>虚析构函数是为了解决基类的指针指向了派生类的对象，并用基类的指针删除派生类的对象。只有带有多态性质的基类，即定义了virtual函数的基类，需要定义虚析构函数。对于非多态性质的基类，不需要定义虚析构函数。
5>纯虚函数是指基类不给出具体的函数实现，而是由派生类实现。
6>基类的函数被声明为虚函数，派生类不论加不加virtual修饰符，都是虚函数。

3)虚函数表
1>虚函数表是在编译阶段产生的。虚函数指针是在运行阶段，构造函数时候创建的。
2>带有虚函数类的对象会有一个虚函数表指针，指向虚函数表。类的虚函数都会存放到虚函数表中。虚函数表不会影响类的大小。sizeof带有虚函数的类，只会计算虚函数指针及类成员变量的大小。
3>只要基类有虚函数，不论派生类是否实现都有虚函数表。派生类和基类的虚函数表地址不一样，派生类没有重写基类虚函数的时候两份虚函数表的内容是一样的。
3>相同类的不同对象共用同一份虚函数表。
4>派生类重写了基类的虚函数，那么派生类的虚函数表中保存的是派生类重写的虚函数地址，而不是基类的虚函数地址。
5>在多重继承的情况下，多个基类如果都有虚函数的话，派生类会有多个虚函数表指针指向不同的虚函数表，不同的虚函数表分别存储了不同基类的虚函数。
6>在多重继承的情况下，如果派生类有定义自己的虚函数，那么虚函数存放在第一个基类的虚函数表中。
7>在多重继承的情况下，如果多个基类有相同名字的虚函数，同时派生类重写了该虚函数，会同时重写多个基类的虚函数。

24、explicit关键字
explicit关键字用于修饰只有一个入参的构造函数。作用是防止隐式转换。
比如类A，定义了构造函数A(int i) {...}。在实例化A时，A a(1);和A a=1;两种写法都正确。因为A a=1;被隐式转换了。
如果加了explicit关键字修饰，则第二种写法会编译错误。
另，如果构造函数是一个形参带若干个默认参数的形参，也是可以使用explicit修饰。

25、如何定义一个只能在堆上创建的类？
将析构函数设置为private类型。
如何定义一个只能在栈上创建的类？
重载new和delete操作符同时将其设置为private类型。

26、类型转换运算符
1)static_cast
静态类型转换，不保证安全性。type a = static_cast<type>(b)
1>常见类型转换，比如enum->int,int->char等。
2>void类型指针转换成目标类型指针(不安全)。
3>父类指针和子类指针的转换，但不安全。一般父类和子类指针之间的转换用dynamic_cast。
4>不能进行无关类型的转换，也不能去掉const/volatile/__unaligned的属性。
5>C++的隐式转换是通过static_cast实现。

2)dynamic_cast
动态类型转换，运行时类型识别(RTTI)，保证安全性。用于父类和子类之间的类型转换，同时要求必须有虚函数。
1>type* p = dynamic_cast<type*>(e)，指针之间的动态转换，如果转换失败返回nullptr。
子类指针转换成父类指针成功，父类指针转换成子类指针失败。
2>type& d = dynamic_cast<type&>(e)，引用之间的动态转换，如果转换失败抛出bad_cast异常。
3>对空指针nullptr可以使用dynamic_cast，转换成目标类型的空指针。

3)const_cast
int *p = const_cast<int*>(cp);//cp是const int*
用于删除指针或引用的const、volatile特性。比如将const int*转换为int*。

4)reinterpret_cast
无关类型的之间的转换。type a = reinterpret_cast<type>(expression)
只是对对象的类型进行重新解释，不会借助转换对对象数据进行调整，也不会判断对象转换前后的类型本身是否可以合法的进行转换。非安全。
1>将指针转换成足够大的整型变量。
2>将整形或enum转换成指针。
3>从一个类型的函数指针转换成另一个类型的函数指针。
4>从一个类的对象的指针转换成另一个类的对象指针。可以用于类成员和成员函数。

27、constexpr函数指可以赋值给常量表达式的函数。要求函数返回的值必须是字面值且只有1个return语句。
constexpr函数被隐式的指定成内联函数。
constexpr int *p，p本身是一个常量不能改变。p所指向的内存必须是在编译阶段就能确定的。比如全局变量，静态变量。是不能指向局部变量的地址。

28、模板(函数模板、类模板、类型形参、非类型形参)
1)模板在编译的时候不会生成代码，只有在模板实例化的时候编译器才会生成代码。
2)函数模板可以定义非类型形参，如template <unsigned N, unsigned M> int compare(const int (&p1)[N], const int (&p2)[M]){...}。
但是要求传入的参数必须是字面常量，即可以在编译阶段确定其大小的。不能是局部变量，也不能是动态内存。
非类型形参只能是整数、指针、引用，不能是double、string之类的类型。
3)类模板中可以声明static成员。需要注意的是，相同类型的类模板实例共用相同的static成员，不同类型的类模板实例使用不同的static成员。
4)类模板形参不能采用实参推演的方式。类模板实例化的时候必须明确指定实参的类型，比如A<int> a，不能写成A<2> a;

29、typename关键字
typename有个很关键的作用就是告诉编译器依赖于模板类型的名称是一个类型，比如typename T::iterator *iter;
为什么需要这个设定？因为iterator是依赖于模板参数T的，具体iterator是什么需要等待模板实例化之后才能确定。那么对于下面两种不同的实例化，对于上面的声明会有不同的解释。
struct ContainsA {
    struct iterator {...};
};	这种情况 *iter就是一个ContainsA中iterator类型的指针。
struct ContainsB {
    static int iterator;
};  这种情况上面的声明会被解释为一个乘法表达式，相当于ContainsB中的iterator变量 * iter，这时候编译就会报错，iter未定义。
通过typename关键字，就是为了告诉编译器T::iterator是一个类型，那么对于ContainsB这种情况的报错就会是在ContainsB中没有iterator这种类型。

30、仿函数

31、new、new[]、delete、delete[]、malloc、free
1)malloc从堆分配内存，new从自由存储区分配内存。new分配的内存不一定是堆内存，也可以是静态存储区。placement new甚至不会分配内存。
2)new返回的指针是具体的对象指针，而malloc返回的指针是void类型的，需要使用者自己保证安全性。
3)malloc分配内存失败返回的是NULL，new分配内存失败是抛异常bad_alloc。
4)malloc分配内存需要自行计算分配内存的大小，new是由编译器自动计算的。
5)new、delete会调用对象的构造或者析构函数，malloc和free不会。
6)new[]和delete[]专门用于分配和释放数组类型。malloc不会没有这个设定。delete[]会为数组中每个成员调用析构函数，而delete只会调用一次析构函数。
7)new和delete是运算符可以被重载，malloc和free是标准库函数不可以重载。
8)对于自定义类型，new[]会在首地址前4个字节定义数组长度，调用delete[]时候会根据长度来析构整个数组。对于内置类型不需要记录数组长度。

32、new operator、operator new和placement new
1)new operator是指new操作符，包括分配内存和构造对象两个函数。
2)operator new是一个函数而不是运算符。可以被重载，分为全局重载void* ::operator new(size_t size)和类重载void* A::operator new(size_t size)。operator new是new操作符的第一步。如果被重载了，则调用重载之后的operator new()。
在无法申请指定大小的内存时，如果设置了new_handler会调用new_handler。如果没有设置则抛出bad_alloc异常。
3)placement new是在一个已经存在的内存上调用对象的构造函数。对象使用完毕时需要人为调用对象的析构函数。

33、构造函数和析构函数的调用顺序
构造函数；基类构造函数->成员类构造函数->当前类构造函数。
析构函数：当前类析构函数->成员类析构函数->基类析构函数。
虚基类在其他任意类之前调用构造函数，在其他任意类之后调用析构函数。
成员的初始化顺序是根据成员在类中定义的顺序决定的，而不是根据初始化列表决定。

34、lambda函数
语法格式[capture](parameters) mutable->return-type {statement};
[capture]是捕捉列表，也是lambda函数的引出符号。捕捉列表中的捕捉项以逗号分隔。
[var]：值传递的方式捕捉指定的var变量。
[=]：值传递的方式捕捉父作用域的变量，包括this指针。
[&var]：引用传递捕捉指定的变量var。
[&]：引用传递的方式捕捉父作用域的变量，包括this指针。
[this]：值传递的方式捕捉当前的this指针。
[=,&a,&b]：值传递的方式捕捉父作用域的变量，变量a和b以引用传递的方式捕捉。
[&,a,this]：引用传递方式捕捉父作用域的变量，变量a和this指针以值传递的方式捕捉。
(parameters)：参数列表，如果不需要参数列表，则连同()一起省略。
mutable：lambda函数默认是const函数，mutable可以取消其常量性，但如果用mutable修饰，参数列表不能省略，即使参数列表为空。
->return-type：返回值类型，如果返回值类型明确，可以省略。由编译器自行推导。如果没有返回值也可以省略。比如返回int，写作->int。
lambda函数默认是const函数，即函数内部不能修改变量。通过mutable修饰可以解除这个限定。

35、decltype关键字
c++可以通过auto关键字来修饰一个变量，该变量的类型则是由表达式推导而来。但是同时该变量也被表达式初始化了。
如果只需要推导类型，不希望被初始化，就使用decltype关键字，decltype(表达式) 变量名。

引用
引用就是变量的别名，本身不占用内存。引用在声明的时候就要初始化， 而且之后不能改变其所代表的对象。不能给数组建立引用。
引用作为函数参数不会像形参一样重新分配一个内存空间。函数内部对于引用操作实际上就是操作其所所指对象的地址。
引用作为函数的返回值需要注意，1)不能返回局部变量的引用。2)不能返回函数内部new分配的内存的引用，这样会导致内存无法被释放。3)可以返回类成员的引用， 不过一般作为const。

C++内存管理
存储区：堆、栈、自由存储区、全局/静态存储区、常量存储区、代码区
概括来说，new/delete是在自由存储区上申请和释放内存，而malloc/free是在堆上申请和释放内存。
但在默认情况下new/delete是通过malloc和free来实现的，这种条件下自由存储区和堆是等价的。但如果通过重载new/delete，没有调用malloc/free来申请和释放内存，而是通过其他方式，比如全局变量作为内存池等，这种条件下，自由存储区和堆内存就不相同了。
所以准确的说堆内存是操作系统本身管理的内存，是物理概念。而自由存储区是一个逻辑改变，用来表示通过new/delete管理的内存。
栈内存的增长方向是从大到小，堆内存的增长方向是从小到大。

友元函数
由于友元函数没有this指针，其参数有三种情况：1)访问static成员变量或者全局变量，不需要参数。2)访问非static成员变量，需要对象做参数。3)如果访问的是全局对象的成员，不需要参数。
友元函数是类外函数，因此声明在类的私有区还是公有区没有区别。
友元函数可以直接调用，不需要对象或指针。
友元关系不能被继承，基类的友元对派生类无效。友元关系是单向的，A是B的友元类，不代表B是A的友元类。

public、protect、private
private：只能由类成员函数访问，不能通过类对象或派生类访问。
protect：可以由类成员函数和派生类访问，不能通过类对象访问。
不论是public、protect、private都可以通过友元函数访问。
public继承：父类中的成员变量、成员函数的权限不变，public还是public、protect还是protect、private还是private。
protect继承：父类中的成员变量、成员函数的权限改变，public变成protect。protect还是protect、private还是private。
private继承：父类中的成员变量、成员函数的权限改变，public变成private、protect变为private。private还是private。

结构体末尾长度为0或长度为1的数组
长度为0的数组一般用来构造动态数组或者缓冲区。空数组的优势在于：
1.不需要初始化。不占用任何空间。如果用指针，指针变量本身会消耗内存空间。
2.一次性分配内存，malloc(sizeof(struct) + buf_len)，就将结构体和缓冲区一起分配了。
3.如果是指针的话就需要分两次分配内存。而且如果第二次内存分配失败，需要回滚释放第一次分配的内存，增加了编码的复杂度。即使分配成功，在最终释放的时候也需要释放两次。
4.两次分配还容易造成小内存以及内存碎片的问题。
长度为1的数组作用和长度为0的数组是一样的，只是因为有些编译器不支持使用长度为0的数组，因此才使用长度为1的数组。