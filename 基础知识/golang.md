# golang
## defer
defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;  
defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露；  
多个 defer 调用顺序是 LIFO（后入先出），defer后的操作可以理解为压入栈中；  
defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。defer可以修改函数最终返回值，
修改时机：有名返回值或者函数返回指针；  

## channel&select
1. channel分为只读channel、只写channel和可读可写channel。channel需要通过make来分配长度，否则不能使用；  
使用for + range来循环管道之前，管道需要调用close关闭。否则会出现deadlock；  

2. 不带缓冲区的channel，只能存1个数据，而且只有当存的数据被取出之后，才能存下一个数据，否则会阻塞。
带缓冲区的channel，可以保存多个数据；  
只读只写的channel一般用于函数的入参或者返回值，规定channel在函数内部是只读还是只写的属性；  
读写channel的时候可以通过time.Tick来控制channel读写的频率；  

3.select与channel配合使用，用于等待一个或者多个channel输出； 
至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错；   
如果有一个case满足，则执行满足的case；  
如果有多个case满足，则随机执行一个case；  
如果没有case满足，select会阻塞。如果不想让select阻塞，则可以设置default。没有case满足的时候，select会执行default，执行完成后退出；  
此时需要用一个for循环来不断的调用select，监听是否有case满足；  

## make&new
共同点：给变量分配内存；   
不同点：   
1）作用变量类型不同，new给string,int和数组分配内存，make给切片，map，channel分配内存；   
2）返回类型不一样，new返回指向变量的指针，make返回变量本身；   
3）new 分配的空间被清零。make 分配空间后，会进行初始化；   

## 数组&slice
相同点：
1)只能存储一组相同类型的数据结构；  
2)都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取；  
3)函数传递中两者都是值传递；  
区别：
1）数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容；  
2）数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变；   

slice扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍；  

关于 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice；  

## map
1. map不是并发安全，map无序；  
2. 使用map一定要make，否则panic；   
3. map删除一个key内存是否会释放？如果key对应的val是int、bool、float、string、数组、结构体等不会释放，如果对应的是指针、slice、map、chan等会释放；  
4. map的value不能取地址，因为map扩容之后其value成员的地址会发生变化；  
### 扩容规则
map扩容时使用渐进式扩容；  
由于map扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，因此 G采取了一种称为‘渐进式’的方式，原有的key并不会一次性搬迁完毕，每次最多只会搬迁2个bucket。只有在插入或修改、删除key的时候，都会尝试进行搬迁buckets的工作。先检查oldbuckets是否搬迁完毕，具体来说就是检查oldbuckets是否为 nil；  
负载因子 = 哈希表中元素数量 / 桶的数量；  
1. 翻倍扩容  
当负载因子超过6.5时就会触发翻倍扩容。会创建一个新的bucket数组，其成员数量是旧数组的两倍。旧数组的成员逐渐迁移至新数组中。旧数组则由GC机制来回收；  
2. 等量扩容  
如果负载因子没有超过6.5但溢出桶数量过多，会进行等量扩容。正常bucket bmap中只能存放8组键值对，当存满之后多余的数据就放在溢出桶中，extra bucket。当溢出桶数量很多，但大量空闲的时候就会进行等量扩容。创建一个和原始bucket数量一样的新bucket，将map成员的重新排列，节省空间提升查找效率；  

## init函数
1. 包级别定义。go程序导入的包需要被初始化，先初始化包级别声明的变量，然后执行init函数。init函数仅执行一次；   
2. 如果需要执行包的init函数，但是又不会用到包中的任何方法或者变量，这种情况如果直接import 包是会提示没有使用的错误。可以使用import _ 包。每个包都可以有一个或者多个init函数。如果一个包包含多个源文件，那么init函数执行顺序默认是按照文件名排序的；  
3. 不同的包init函数执行顺序与包导入的顺序是一致的。不论一个包被导入多少次，其init函数只执行一次；   

## context
context用于多个goroutine之间传递上下文信息，目的是实现并发控制，超时控制；  
用法main函数调用context.Background创建一个根context。根context不能取消，不会超时，也没有值；  
goroutine在根context的基础之上调用withCancel方法创建一个可以取消的contex；  
每一级context都有个map结构，用来保存由它所创建的子goroutine中的context；  
withCancel方法还会返回一个取消函数。当取消函数被调用的时候，会遍历上面说的map结构，对每个子contenxt都执行cancel操作。同时将自身从父context的map中删除；  
如果父context超时，那么子context也会超时。不需要单独处理子context超时；  
context作为参数传给函数，但不要传nil，如果没有可以传入的实参，那么就传入context.TODO；  

## struct结构体之间能不能比较
如果结构体所有的成员变量都可以比较，那么结构体可以比较；  
如果结构体有不可比较的成员变量，那么结构体不可比较。slice、map都不可比较；  
结构体之间进行转换要求结构体本身要有相同的字段名、字段类型、字段个数；  
因此只有可比较的struct才能作为map的key；  

## 垃圾回收
v1.3 标记清除法（需要STW，stop the world）；  
v1.5 三色标记法 + 写屏障（减少了STW，但仍需要）；  
v1.8 三色标记法 + 混合写屏障（几乎不需要STW）；  
### 三色标记法
采用三色标记法，白色、灰色、黑色；
白色: 未被垃圾回收器访问的对象，可能是活跃的，也可能是垃圾。
灰色: 活跃的对象，已被标记但尚未完成所有子对象的标记。
黑色: 活跃的对象，已完全标记，包括其所有子对象。
### 三色标记法的工作流程
初始化: 将所有的对象初始化为白色，表示它们尚未被访问。
并发标记: 每次GC回收开始，首先从根对象开始，垃圾回收器并发地遍历对象图，其所有直接可达的对象标记为灰色，并将这些对象加入到工作队列中。
处理工作队列: 垃圾回收器会从工作队列中取出对象，继续标记它们的子对象，直到所有子对象都被标记。一旦一个对象的所有子对象都被标记，该对象就会从工作队列中移除，并被标记为黑色。
结束并发标记: 当工作队列清空，且没有更多对象需要标记时，垃圾回收器结束并发标记阶段。
清除阶段: 所有白色对象（即未被标记的对象）被认为是垃圾，垃圾回收器将这些对象回收。
### 三色不定式
强三色不变式:强三色不变式要求在垃圾回收过程中，黑色对象不得引用白色对象。这一规则确保了所有被黑色对象引用的一定是活跃的，从而防止了活跃的白色对象被错误回收。
弱三色不变式:弱三色不变式则允许黑色对象引用白色对象，但要求白色对象存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象，防止它被回收。
### 写屏障
1. 插入写屏障: 当一个黑色对象A引用一个白色对象B时，触发插入写屏障。具体操作是将B对象标记为灰色，确保B对象不会被错误地当作垃圾回收。这一机制维护了强三色不变式，即不存在黑色对象引用白色对象的情况。对于栈上的对象，由于没有插入写屏障，垃圾回收器会在适当的时候启动STW（stop the world机制），重新扫描栈上的空间，以确保所有活跃的对象都被正确标记。
2. 删除写屏障: 当一个对象的引用被删除时，触发删除写屏障。如果被删除引用的对象是白色的，它会被暂时标记为灰色，这样可以保护它不被当前周期的垃圾回收器回收，实现了弱三色不变式。这意味着，即使一个对象的最后一个引用被删除，只要存在从灰色对象到该白色对象的路径，该白色对象就不会被立即回收。
### 混合写屏障
在GC开始时，栈上的所有对象被扫描并标记为黑色，避免了对栈的二次扫描，减少了STW的需要；  
GC进行期间，任何新在栈上创建的对象默认被视为黑色；  
被删除的对象标记为灰色，添加的对象标记为灰色；  
混合写屏障机制满足了一种变形的弱三色不变式，确保了在并发环境下，对象的引用变更得到正确处理，同时减少了对STW的依赖；  
### 混合写屏障的应用场景
堆到栈的引用变更: 当一个堆对象删除对另一个对象的引用，而该对象成为另一个栈对象的下游时，该对象被标记为灰色，类似于删除写屏障的行为；  
栈到栈的引用变更: 当一个栈对象删除对另一个对象的引用，而该对象成为另一个栈对象的下游时，该对象保持黑色状态，如果没有成为另一个栈对象的下游，可能会在后续的GC周期中被回收；  
堆到堆的引用变更: 当一个堆对象删除对另一个对象的引用，而该对象成为另一个堆对象的下游时，该对象被标记为灰色，类似于删除写屏障的行为；  
栈到堆的引用变更: 当一个栈对象删除对另一个对象的引用，而该对象成为另一个堆对象的下游时，该对象保持黑色状态，确保了弱三色不变式的维持；  
### 垃圾回收的触发
1. 内存分配触发: 当程序运行过程中，新的内存分配请求导致堆内存使用量增加。如果当前的内存分配超过了一定阈值，GC会被触发以释放不再使用的内存。Go语言提供了GOGC环境变量，允许开发者或用户设置GC触发的堆内存增长比例。默认情况下，GOGC的值设置为100，表示当堆内存使用量达到上次GC后两倍时触发GC。如果GOGC的值设置得更高，那么堆内存会在更大程度上增长后才触发GC；如果设置得更低，则会更频繁地触发GC；  
2. 强制GC(用户显式调用): 除了自动触发外，开发者还可以通过调用runtime包中的GC()函数强制立即进行垃圾回收；  
3. 周期性GC: 为了确保即使在内存分配非常少的情况下也能定期进行垃圾回收，Go运行时系统还实现了一个周期性的GC机制。这个机制由runtime.forcegcperiod变量控制，默认情况下大约每2分钟触发一次GC，即使GOGC阈值未被超过；  

## GMP调度器
G：代表创建的一个个gorouting协程；  
P：代表逻辑处理器，P的数量通过GOMAXPROCS设置。一般设置为CPU的最大核数；  
M：代表系统线程；  
早期是GM模型，但由于多个G对应多个M，会产生全局锁，且G在不同的M之间的切换也会造成额外开销；  
后演化出GMP模型，P代表了一个虚拟的处理器，它维护一个局部可运行的G的队列，可以通过CAS的方式无锁访问。每个G想要运行起来，需要被分配到一个P。工作线程M会优先使用自己的局部运行队列中的G，只在必要时才会访问全局运行队列，大大减少了锁冲突，提高了大量G的并发性；  
### 核心思想
1. 尽可能服用线程M：避免频繁的线程创建和销毁；   
2. 利用多核并行能力：限制同时运行的M线程数，数量一般等于CPU核心的数量，这个数量可以通过设置GOMAXPROCS来指定。没有找到P的M会放入空闲M列表，没有找到M的P也会放入空闲P列表；  
3. Work Stealing任务窃取机制：M优先执行绑定的P上的本地队列中的G，如果本地队列为空，则从全局队列中获取G，也可以从其它M偷取G来运行；  
4. Hand Off 交接机制：当M阻塞时，会将M上的P的运行队列交给其它M执行；  
5. 基于协作的抢占机制：每个G运行10ms就要让出M，交给其它G去运行，防止新创建的G一直获取不到M执行的问题；  
6. 基于信号的抢占机制：Go 1.14引入了基于信号的抢占式调度机制，能够解决GC垃圾回收和栈扫描时存在的问题；  