1、宏
比较大小的宏 #define MIN(x, y) ((x) < (y) ? (x) : (y))
#和##的作用
#的作用是将参数转换成字符串
#define STR(x) #x
STR(hello)展开之后为"hello"

##的作用是参数连接
#define NAME(x) name_##x
NAME(1)展开之后为name_1
如果没有##
#define NAME(x) name_x
NAME(1)展开之后为name_x

2、static关键字
修饰存储类型为静态存储类型。
静态局部变量：函数运行结束，变量值会保留，下次执行能够使用。
静态全局变量：除了上面一条之外，只能当前源文件内使用，其他文件即使使用extern也无法使用。
静态函数：只能当前源文件内使用，其他文件即使使用extern也无法使用。
局部变量变为静态变量是改变了其存储区域从而改变了其生命周期。全局变量变为静态变量则是改变了其作用域，限制了其作用范围。

3、violate关键字
强制编辑器每次都从内存中读取变量的值，而不从编辑器优化之后的寄存器中读取。
一般用于：硬件时钟、多线程中的共享变量等。

4、const关键字
const int *p 指向整形常量的指针，p的值可以改变，但*p的值不能改变。
int * const p 指向整形的常量指针，p的值不能改变，但*p的值可以改变。
const修饰的对象，只能使用类中const成员函数，非const对象可以使用类中所有的成员函数。const对象的成员变量不可修改。
const成员函数不能修改对象的成员变量，但可以修改被mutable修饰的成员变量。mutable不可以修饰const类型的成员变量。
const成员函数可以访问对象的成员变量，不论成员变量是否被const修饰。
非const成员函数可以访问非const对象的非const成员变量和const成员变量，但是不能访问const对象的任意成员变量。
如果成员函数不对成员变量进行修改操作，应该尽量声明为const成员函数。
类中的const成员变量几种赋值方式：
1)在声明类的时候赋值，只在c++11后支持。
2)在类构造函数后面的初始化参数列表中赋值，如类A中a1是const int成员变量，A::A():a1(123){...}。需要注意的是初始化参数列表只能写在构造函数定义的地方，不能写在构造函数声明的地方。
3)给const成员加上static关键字，这样可以直接在类外部赋值，如const int A::a1 = 123。
假设类A有一个成员函数void funcA();,该成员函数重载了void funcA() const;，那么对于A a; a.funcA();会调用非const类型的成员函数，而const A a; a.funcA();则会调用const类型的成员函数。
4)如果const修饰成员函数体，表示该成员函数不会修改成员变量的值。

5、sizeof关键字
编译阶段处理，对于数组为数组大小，对于指针4字节(32位系统)
空结构体sizeof的结果为1。
sizeof和strlen的区别：
1)sizeof是一个关键字，strlen是一个函数。
2)sizeof求得是字节长度，而strlen是实际使用长度。
3)strlen求长度是以'\0'结束的。
4)sizeof是在编译的时候计算，而strlen是在运行的时候计算。

6、字节对齐
1)结构体成员是按照#pragma pack()指定的长度和数据成员自身长度较小的那一个进行对齐。
2)结构体整体是按照#pragma pack()指定的长度和最大数据成员长度较小的那一个进行对齐。
3)包含子结构体，子结构体成员按照#pragma pack()指定的数值和子结构体最大成员长度较小的那一个进行对齐。
4)_attribute(aligned(n)),结构体成员按n字节对齐，如果成员长度大于n，则按成员长度对齐。

7、inline与宏的区别
1)内联函数在编译时展开，而宏在预编译时展开
2)在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
3)内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。
4)宏不是函数，而inline是函数
5)宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。
6)inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。
7)宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，
也就不能享受编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。

8、register关键字
register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。
register的限制
1)register变量必须是能被CPU所接受的类型。
这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。
2)因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。
3)只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。
在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。
4)局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c;
5)由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），
因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。

9、堆内存、栈内存、静态存储区
静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。
栈内存：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
栈内存是连续的内存区域，不会产生碎片。栈是由高地址向低地址方向生长。
堆内存：用户通过动态申请的内存。堆内存不是连续的内存区域，频繁的创建和删除容易产生内存碎片，使系统运行效率降低。堆是由低地址向高地址方向增长。
linux栈内存大小默认是10M，可以通过ulimit -s来设置。

10、大端序、小端序、主机序、网络序
大端序：数据的高位字节存放在地址的低端 低位字节存放在地址高端。
小断续：数据的高位字节存放在地址的高端 低位字节存放在地址低端。
比如存放 0x12345678
地址由高到低
大端序：78 56 34 12
小端序：12 34 56 78
主机序根据CPU不同可以是大端序也可以是小端序。
网络序一定是大端序。
Intel的CPU是小端序。

11、宏与const的区别
1)宏在预编译阶段展开，const常量在编译运行阶段使用。
2)宏没有类型，不会做类型检查。const变量有类型，编译阶段会做检查。
3)宏不会分配内存，只是展开。const常量会分配内存。

12、拷贝构造函数
拷贝构造必须的参数是本类型的一个引用变量。
class CExample
{
public:
    //构造函数
    CExample(int b)
    {
        a=b;
        printf("constructor is called\n");
    }
    //拷贝构造函数
    CExample(const CExample & c)
    {
        a=c.a;
        printf("copy constructor is called\n");
    }
    //析构函数
    ~CExample()
    {
        cout<<"destructor is called\n";
    }
};
调用时机：
1)类对象作为函数参数。
2)类对象作为函数返回值。
3)类对象通过另外一个类对象来初始化。

13、浅拷贝、深拷贝
浅拷贝只是对类成员变量进行简单的复制操作。那么对于指针类型的成员变量会出现问题。
假设类实例a.p = new int(1);，类实例b = a;，b.p的值也是1，但实际上b.p和a.p是指向同一块内存。
深拷贝则是对于类动态成员变量进行重新分配内存的操作。
C++默认的拷贝构造函数是浅拷贝模式。因此对于有动态成员的类，构造函数需要自定义一个深拷贝的拷贝构造函数。

14、重载overload、覆盖override、重写overwrite
overload：同一个类当中，函数名相同， 参数不同(类型不同或者数量不同，或者两者都不同)。不以返回值类型作为重载的判断条件。
override：父类和子类中，子类实现父类中的虚函数。
overwrite：父类和子类中，子类实现父类中的非虚函数。

15、抽象类：含有纯虚函数的类。抽象类不能直接生成对象。
接口类：仅含有纯虚函数的类。
聚合类；用户可以直接访问其成员，且具有特殊的初始化语法形式。
1)所有成员都是public。
2)没有定义任何构造函数。
3)没有类内初始化。
4)没有基类，也没有virtual函数。
聚合类的缺点：所有成员都是public，有用户自行初始化成员容易出错，添加或删除成员后所有的初始化语句都要更新。

16、类的静态成员意味着，不论创建多少个类实例，静态成员都只有一个副本。静态成员的初始化不能放在类定义中，需要单独声明。
静态成员函数不需要类实例就可以调用。但静态成员函数只能访问静态成员变量、其他静态成员函数和类外部函数。而且静态成员函数没有this指针。

17、重载确定的步骤
1)确定候选函数，候选函数需要与被调函数同名，且在调用处其声明可见。
2)选择可行函数，可行函数需要与调用函数参数个数相同。且每个实参类型都能对应匹配或可允许隐式转换。
3)寻找最佳匹配，如果某一个函数其每个实参的匹配都不劣于其他可行函数的匹配，或某一个函数其至少有一个参数的匹配由于其他可行函数提供的匹配。则该函数为最佳匹配函数。

18、顺序容器vector、list、deque
有几种初始化方式：
1)vector<int> v1(v2) v1是v2的副本，要求容器类型相同，元素类型相同。
2)vector<int> v1(v2.begin(), v2.begin() + 3) v1初始化为v2的一部分，不包含v2.begin() + 3这个元素。适用于所有容器。不要求容器类型相同，也不要求元素类型相同，只要元素类型能够互相转换。
3)vector<int> v1(3, 10) 指定初始化元素的个数和元素的值。要求值类型和容器元素类型相同，或者可以转换。
如果容器的元素也是一个容器，要注意写法vector< vector<string> >，注意空格一定要有。
list的迭代器不支持>、>=、<、<=的操作，也不支持加减法操作。但是支持自增和自减。

19、基类先与派生类被初始化。一个类中的成员变量的初始化顺序与其声明时成员变量的顺序是一致的，与构造函数中成员变量初始化的顺序无关。
类成员变量在构造函数中采用成员初始化列表的方式来进行初始化。这个对于const成员变量很有用。
如类A，构造函数A::A(const int i, const int j):a1(i),a2(j){};

20、编译器会为一个类创建默认的构造函数、拷贝构造函数、赋值操作符函数和一个析构函数，如果类本身没有声明这些函数。
如果一个类禁止拷贝操作，就将拷贝构造函数和赋值操作符函数声明为private，且只声明不实现。这样，即可以避免编译器生成默认的拷贝构造函数和赋值操作符函数，也可以防止成员函数和友元函数调用拷贝构造函数和赋值操作符函数。

21、继承
1、创建一个派生类的对象时，基类的构造函数会先于派生类的构造函数执行。如果基类的构造函数有调用虚函数，只会执行基类实现的虚函数，不会执行派生类对于虚函数的实现。
2、基类的引用或指针可以指向一个派生类的对象。
3、自定义派生类的构造函数时，除了要初始化派生类的成员变量，还需要调用基类的构造函数，初始化基类的成员变量。
4、虚继承
虚继承用来解决C++菱形继承问题。在菱形继承的情况下，派生类中会有最上层基类的多份拷贝。一来浪费内存空间，二来如果使用最上层基类的指针指向派生类对象时，会出现二义性。因为多份拷贝的问题，基类指针无法确定应该使用哪一份拷贝。
虚继承在派生类中会有一个指针指向虚基类表，其中记录了子类相对于虚基类的偏移量。派生类对象在构造时，虚基类的构造函数只会调用一次，

22、智能指针
1)auto_ptr，在C++11中已被弃用，有以下特点：
1>auto_ptr赋值给另外一个auto_ptr之后，对象的所有权会发生转移。如auto_ptr p2 = p1;此时p2指向p1所指向的对象，而p1则会指向空的对象。
2>auto_ptr不能作为函数的返回值和函数参数，也不能在容器中保存auto_ptr。
为什么auto_ptr不能作为vector成员类型？
STL的容器要对能够对对象进行安全的赋值操作，拷贝之后原对象不会改变。而auto_ptr拷贝之后原指针会被设定指向NULL。比如vector < auto_ptr <int> > vp; auto_ptr <int> vp1 = vp[0]; 如果这段代码是可以编译运行的，那么vp[0]在赋值之后会变成NULL。这显然是不能被允许的。

C++11之后智能指针分为shared_ptr、unique_ptr、weak_ptr。
uique_ptr独占指针对象，指针对象的生命周期与其一致。
shared_ptr可共享指针对象，指针所指向的对象在所有关联其指针生命周期结束时结束。
weak_ptr作为shared_ptr的辅助指针，不能决定其所指对象的生命周期。需要lock成shared_ptr才能引用其所指对象。
智能指针的构造函数都有explicit关键字修饰，不支持隐式转换如shared_ptr<int> sp = new int(100);这种写法会报错。要写成shared_ptr<int> sp(new int(100));
或者写成shared_ptr<int> sp = make_shared<int>(100);需要注意的是不能对指针使用make_shared，而=赋值则一定要使用指针。这段描述对于unique_ptr也适用。
1)shared_ptr有引用计数。用shared_ptr初始化另一个shared_ptr、作为函数入参、作为函数返回值，其引用计数就会递增。shared_ptr赋予一个新值、share_ptr离开作用于则引用计数会递减。当引用计数为0，则会释放其管理的对象。
shared_ptr<int> sp = p; //会让p的引用计数+1
sp = q; //q的引用计数+1，sp之前指向的对象引用计数-1，如果减为0则自动释放。
sp.reset(new int(1024)); //sp重新指向一个新的对象，原对象的引用计数-1。
2)unique_ptr是独享所有权的指针，无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作。保存指向某个对象的指针，当它本身被释放，指向的对象也会被释放。
unique_ptr<int> up1(new int(100));
unique_ptr<int> up2(new int(50));
up2 = move(up1); //不能直接up2 = up1
up2.reset() //释放up2所指向的对象，并将up2设为null。
3)weak_ptr是为了防止shared_ptr相互引用时，引用计数永远不会下降为0，而导致资源无法释放。weak_ptr不会增加对象的引用计数。
创建weak_ptr需要shared_ptr来初始化。weak_ptr<int> wp(sp);
不能直接访问weak_ptr所指向的对象，需要通过lock()，如果wp所指向的对象存在，lock(wp)会返回一个shared_ptr，如果wp所指向的对象已经被释放，那么lock(wp_会返回一个空的shared_ptr。
wp.expire()返回true或false来表示对象是否已经释放。

23、多态的实现
重载多态(编译期)：函数重载、运算符重载
子类型多态(运行期)：虚函数
参数型多态(编译期)：类模板、函数模板
强制多态(编译期/运行期)：基本类型转换、自定义类型转换

模板又分为函数模板和类模板。在编译期根据模板和实际的参数类型对模板进行实例化。
函数模板可以定义为inline或constexpr。普通函数可以定义模板，成员函数也可以定义为模板，但成员函数模板不能是虚函数。

2)虚函数
1>static成员函数不能是虚函数。
2>构造函数不能是虚函数。因为在调用构造函数的时候指向虚函数表的指针还没有创建，只有构造完成才会创建。
3>inline可以用来修饰虚函数，但当虚函数表现出多态性时不能内联。就是不能通过指针或者引用的方式调用虚函数。
4>虚析构函数是为了解决基类的指针指向了派生类的对象，并用基类的指针删除派生类的对象。
5>纯虚函数是指基类不给出具体的函数实现，而是由派生类实现。

3)虚函数表
1>虚函数表是在编译阶段产生的。虚函数指针是在运行阶段，构造函数时候创建的。
2>带有虚函数类的对象会有一个虚函数表指针，指向虚函数表。类的虚函数都会存放到虚函数表中。虚函数表不会影响类的大小。sizeof带有虚函数的类，只会计算虚函数指针及类成员变量的大小。
3>只要基类有虚函数，不论派生类是否实现都有虚函数表。基类的虚函数表和派生类的虚函数表不是同一张表。
3>相同类的不同对象共用同一份虚函数表。派生类和基类的虚函数表地址不一样，派生类没有重写基类虚函数的时候两份虚函数表的内容是一样的。
4>派生类重写了基类的虚函数，那么派生类的虚函数表中保存的是派生类重写的虚函数地址，而不是基类的虚函数地址。
5>在多重继承的情况下，多个基类如果都有虚函数的话，派生类会有多个虚函数表指针指向不同的虚函数表，不同的虚函数表分别存储了不同基类的虚函数。

24、explicit关键字
修饰构造函数，可以防止隐式转换和拷贝初始化。
修饰转换函数，可以防止隐式转换。

25、如何定义一个只能在堆上创建的类？
将析构函数设置为private类型。
如何定义一个只能在栈上创建的类？
重载new和delete操作符同时将其设置为private类型。

26、类型转换运算符
static_cast:static_cast<type> (expression)，将express转换为type类型，在编译期间进行转换。但不保证转换安全。比如void *ptr = &d; double *dp = static_cast<double *> (ptr);这样可以将一个void *指针转换成一个double *类型的，
但是编译器不会检查d是不是一个double类型的变量，这个要人为保证正确性。
dynamic_cast:type必须是一个类类型，通常情况下要含有虚函数。dynamic_cast在运行期间进行类型转换。
dynamic_cast<type *> (e)
dynamic_cast<type &> (e)
dynamic_cast<type &&> (e)
const_cast:用于删除const、volatile和__unaligned特性。比如将const int转换为int。
reinterpret_cast:reinterpret_cast<type> (expression)，只是对对象的类型进行重新解释，不会借助转换对对象数据进行调整，也不会判断对象转换前后的类型本身是否可以合法的进行转换。非安全。

27、constexpr函数指可以赋值给常量表达式的函数。要求函数返回的值必须是字面值且只有1个return语句。
constexpr函数被隐式的指定成内联函数。
constexpr int *p，p本身是一个常量不能改变。p所指向的内存必须是在编译阶段就能确定的。比如全局变量，静态变量。是不能指向局部变量的地址。

28、模板(函数模板、类模板、类型形参、非类型形参)
1)模板在编译的时候不会生成代码，只有在模板实例化的时候编译器才会生成代码。
2)函数模板可以定义非类型形参，如template <unsigned N, unsigned M> int compare(const int (&p1)[N], const int (&p2)[M]){...}。
但是要求传入的参数必须是字面常量，即可以在编译阶段确定其大小的。不能是局部变量，也不能是动态内存。
非类型形参只能是整数、指针、引用，不能是double、string之类的类型。
3)类模板中可以声明static成员。需要注意的是，相同类型的类模板实例共用相同的static成员，不同类型的类模板实例使用不同的static成员。
4)类模板形参不能采用实参推演的方式。类模板实例化的时候必须明确指定实参的类型，比如A<int> a，不能写成A<2> a;

29、typename关键字
typename有个很关键的作用就是告诉编译器依赖于模板类型的名称是一个类型，比如typename T::iterator *iter;
为什么需要这个设定？因为iterator是依赖于模板参数T的，具体iterator是什么需要等待模板实例化之后才能确定。那么对于下面两种不同的实例化，对于上面的声明会有不同的解释。
struct ContainsA {
    struct iterator {...};
};	这种情况 *iter就是一个ContainsA中iterator类型的指针。
struct ContainsB {
    static int iterator;
};  这种情况上面的声明会被解释为一个乘法表达式，相当于ContainsB中的iterator变量 * iter，这时候编译就会报错，iter未定义。
通过typename关键字，就是为了告诉编译器T::iterator是一个类型，那么对于ContainsB这种情况的报错就会是在ContainsB中没有iterator这种类型。

30、仿函数

31、new、delete、new[]、delete[]、malloc、free
1)malloc从堆分配内存，new从自由存储区分配内存。new分配的内存不一定是堆内存，也可以是静态存储区。placement new甚至不会分配内存。
2)new返回的指针是具体的对象指针，而malloc返回的指针是void类型的，需要使用者自己保证安全性。
3)malloc分配内存失败返回的是NULL，new分配内存失败是抛异常bad_alloc。
4)malloc分配内存需要自行计算分配内存的大小，new是由编译器自动计算的。
5)new、delete会调用对象的构造或者析构函数，malloc和free不会。
6)new[]和delete[]专门用于分配和释放数组类型。malloc不会没有这个设定。
7)new和delete是运算符可以被重载，malloc和free是标准库函数不可以重载。
8)对于自定义类型，new[]会在首地址前4个字节定义数组长度，调用delete[]时候会根据长度来析构整个数组。对于内置类型不需要记录数组长度。

32、new operator、operator new和placement new
1)new operator是指new操作符，包括分配内存和构造对象两个函数。
2)operator new是new的重载，是一个函数而不是运算符。分为全局重载void* ::operator new(size_t size)和类重载void* A::operator new(size_t size)。operator new是new操作符的第一步。如果被重载了，则调用重载之后的operator new()。
3)placement new是在一个已经存在的内存上调用对象的构造函数，