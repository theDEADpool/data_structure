1、宏
比较大小的宏 #define MIN(x, y) ((x) < (y) ? (x) : (y))
#和##的作用
#的作用是将参数转换成字符串
#define STR(x) #x
STR(hello)展开之后为"hello"

##的作用是参数连接
#define NAME(x) name_##x
NAME(1)展开之后为name_1
如果没有##
#define NAME(x) name_x
NAME(1)展开之后为name_x

2、static关键字
修饰存储类型为静态存储类型。
静态局部变量：函数运行结束，变量值会保留，下次执行能够使用。
静态全局变量：除了上面一条之外，只能当前源文件内使用，其他文件即使使用extern也无法使用。
静态函数：只能当前源文件内使用，其他文件即使使用extern也无法使用。
局部变量变为静态变量是改变了其存储区域从而改变了其生命周期。全局变量变为静态变量则是改变了其作用域，限制了其作用范围。

3、violate关键字
强制编辑器每次都从内存中读取变量的值，而不从编辑器优化之后的寄存器中读取。
一般用于：硬件时钟、多线程中的共享变量等。

4、const关键字
const int *p 指向整形常量的指针，p的值可以改变，但*p的值不能改变。
int * const p 指向整形的常量指针，p的值不能改变，但*p的值可以改变。
const修饰的对象，只能使用类中const成员函数，非const对象可以使用类中所有的成员函数。const对象的成员变量不可修改。
const成员函数不能修改对象的成员变量，但可以修改被mutable修饰的成员变量。mutable不可以修饰const类型的成员变量。
const成员函数可以访问对象的成员变量，不论成员变量是否被const修饰。
非const成员函数可以访问非const对象的非const成员变量和const成员变量，但是不能访问const对象的任意成员变量。
如果成员函数不对成员变量进行修改操作，应该尽量声明为const成员函数。
类中的const成员变量几种赋值方式：
1、在声明类的时候赋值，只在c++11后支持。
2、在类构造函数后面的初始化参数列表中赋值，如类A中a1是const int成员变量，A::A():a1(123){...}。需要注意的是初始化参数列表只能写在构造函数定义的地方，不能写在构造函数声明的地方。
3、给const成员加上static关键字，这样可以直接在类外部赋值，如const int A::a1 = 123。
假设类A有一个成员函数void funcA();,该成员函数重载了void funcA() const;，那么对于A a; a.funcA();会调用非const类型的成员函数，而const A a; a.funcA();则会调用const类型的成员函数。

5、sizeof关键字
编译阶段处理，对于数组为数组大小，对于指针4字节(32位系统)
空结构体sizeof的结果为1。
sizeof和strlen的区别：
1)sizeof是一个关键字，strlen是一个函数。
2)sizeof求得是字节长度，而strlen是实际使用长度。
3)strlen求长度是以'\0'结束的。
4)sizeof是在编译的时候计算，而strlen是在运行的时候计算。

6、字节对齐
1)结构体成员是按照#pragma pack()指定的长度和数据成员自身长度较小的那一个进行对齐。
2)结构体整体是按照#pragma pack()指定的长度和最大数据成员长度较小的那一个进行对齐。
3)包含子结构体，子结构体成员按照#pragma pack()指定的数值和子结构体最大成员长度较小的那一个进行对齐。
4)_attribute(aligned(n)),结构体成员按n字节对齐，如果成员长度大于n，则按成员长度对齐。

7、inline与宏的区别
1)内联函数在编译时展开，而宏在预编译时展开
2)在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
3)内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。
4)宏不是函数，而inline是函数
5)宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。
6)inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。
7)宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，
也就不能享受编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。

8、register关键字
register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。
register的限制
1)register变量必须是能被CPU所接受的类型。
这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。
2)因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。
3)只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。
在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。
4)局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c;
5)由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），
因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。

9、堆内存、栈内存、静态存储区
静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。
栈内存：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
栈内存是连续的内存区域，不会产生碎片。栈是由高地址向低地址方向生长。
堆内存：用户通过动态申请的内存。堆内存不是连续的内存区域，频繁的创建和删除容易产生内存碎片，使系统运行效率降低。堆是由低地址向高地址方向增长。
linux栈内存大小默认是10M，可以通过ulimit -s来设置。

10、大端序、小端序、主机序、网络序
大端序：数据的高位字节存放在地址的低端 低位字节存放在地址高端。
小断续：数据的高位字节存放在地址的高端 低位字节存放在地址低端。
比如存放 0x12345678
地址由高到低
大端序：78 56 34 12
小端序：12 34 56 78
主机序根据CPU不同可以是大端序也可以是小端序。
网络序一定是大端序。
Intel的CPU是小端序。

11、宏与const的区别
1)宏在预编译阶段展开，const常量在编译运行阶段使用。
2)宏没有类型，不会做类型检查。const变量有类型，编译阶段会做检查。
3)宏不会分配内存，只是展开。const常量会分配内存。

12、拷贝构造函数
拷贝构造必须的参数是本类型的一个引用变量。
class CExample
{
public:
    //构造函数
    CExample(int b)
    {
        a=b;
        printf("constructor is called\n");
    }
    //拷贝构造函数
    CExample(const CExample & c)
    {
        a=c.a;
        printf("copy constructor is called\n");
    }
    //析构函数
    ~CExample()
    {
        cout<<"destructor is called\n";
    }
};
调用时机：
1)类对象作为函数参数。
2)类对象作为函数返回值。
3)类对象通过另外一个类对象来初始化。

13、浅拷贝、深拷贝
浅拷贝只是对类成员变量进行简单的复制操作。那么对于指针类型的成员变量会出现问题。
假设类实例a.p = new int(1);，类实例b = a;，b.p的值也是1，但实际上b.p和a.p是指向同一块内存。
深拷贝则是对于类动态成员变量进行重新分配内存的操作。
C++默认的拷贝构造函数是浅拷贝模式。因此对于有动态成员的类，构造函数需要自定义一个深拷贝的拷贝构造函数。

14、重载和重写
重载是多态的一种表现，即函数名相同，参数列表不同。重载可以是虚函数也可以是非虚函数。重载是一个类内部的实现。
重写是针对于虚函数，子类中重新定义父类中有相同名称和参数的虚函数。
重定义是派生类和基类之间的函数实现。如果函数名相同，参数列表不同，那么不论是不是虚函数，基类的函数将被重定义。
函数名相同，参数列表也相同，那么只要基类的实现不是虚函数，则将被重定义。

15、抽象类：含有纯虚函数的类。
接口类：仅含有纯虚函数的类。
聚合类；用户可以直接访问其成员，且具有特殊的初始化语法形式。
1)所有成员都是public。
2)没有定义任何构造函数。
3)没有类内初始化。
4)没有基类，也没有virtual函数。

16、类的静态成员意味着，不论创建多少个类实例，静态成员都只有一个副本。静态成员的初始化不能放在类定义中，需要单独声明。
静态成员函数不需要类实例就可以调用。但静态成员函数只能访问静态成员变量、其他静态成员函数和类外部函数。而且静态成员函数没有this指针。

17、重载确定的步骤
1)确定候选函数，候选函数需要与被调函数同名，且在调用处其声明可见。
2)选择可行函数，可行函数需要与调用函数参数个数相同。且每个实参类型都能对应匹配或可允许隐式转换。
3)寻找最佳匹配，如果某一个函数其每个实参的匹配都不劣于其他可行函数的匹配，或某一个函数其至少有一个参数的匹配由于其他可行函数提供的匹配。则该函数为最佳匹配函数。

18、顺序容器vector、list、deque
有几种初始化方式：
1)vector<int> v1(v2) v1是v2的副本，要求容器类型相同，元素类型相同。
2)vector<int> v1(v2.begin(), v2.begin() + 3) v1初始化为v2的一部分，不包含v2.begin() + 3这个元素。适用于所有容器。不要求容器类型相同，也不要求元素类型相同，只要元素类型能够互相转换。
3)vector<int> v1(3, 10) 指定初始化元素的个数和元素的值。要求值类型和容器元素类型相同，或者可以转换。
如果容器的元素也是一个容器，要注意写法vector< vector<string> >，注意空格一定要有。
list的迭代器不支持>、>=、<、<=的操作，也不支持加减法操作。但是支持自增和自减。

19、基类先与派生类被初始化。一个类中的成员变量的初始化顺序与其声明时成员变量的顺序是一致的，与构造函数中成员变量初始化的顺序无关。
类成员变量在构造函数中采用成员初始化列表的方式来进行初始化。这个对于const成员变量很有用。
如类A，构造函数A::A(const int i, const int j):a1(i),a2(j){};

20、编译器会为一个类创建默认的构造函数、拷贝构造函数、赋值操作符函数和一个析构函数，如果类本身没有声明这些函数。
如果一个类禁止拷贝操作，就将拷贝构造函数和赋值操作符函数声明为private，且只声明不实现。这样，即可以避免编译器生成默认的拷贝构造函数和赋值操作符函数，也可以防止成员函数和友元函数调用拷贝构造函数和赋值操作符函数。

21、继承、多态
1、创建一个派生类的对象时，基类的构造函数会先于派生类的构造函数执行。如果基类的构造函数有调用虚函数，只会执行基类实现的虚函数，不会执行派生类对于虚函数的实现。
2、基类的引用或指针可以指向一个派生类的对象。
3、自定义派生类的构造函数时，除了要初始化派生类的成员变量，还需要调用基类的构造函数，初始化基类的成员变量。
