Socket的长连接和短连接
概念：长连接是整个通信过程，客户端和服务端只用一个Socket对象，长期保持Socket的连接；后者是每次请求，都新建一个Socket，处理完一个请求就直接关闭掉Socket。所以区分长短连接就是：整个客户和服务端的通讯过程是利用一个Socket还是多个Socket进行的
实现长连接的方法
1.客户端自动推开读取的动作。就算服务端调用了flush方法进行输出刷新，客户端也不一定能退出read的动作，所以还是会阻塞。所以退出动作必须由客户端程序自己完成，我们可以在服务端每发送完一段消息并且刷新前就进行一个写入结束符号的标志，客户端解析到结束符号时，便可直接退出read的循环读取操作，避免一直阻塞。
2.可以调用有读取一定字节到某个数组的read方法，只是针对消息定长的情况。

短连接和长连接有不同的用途：对于某次服务只需要一次回话的客户，使用短连接显得简单；但是，如果该次服务需要很多交互式的通信操作，还是长连接比较高性能，毕竟Socket的打开和关闭都是很耗性能的。

TCP保活功能：主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，是的服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将永远等待客户端的数据，保活功能试图在服务器端检测到这种半开放的连接。
如果一个给定的连接在两个小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下四个状态之一：
1.客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
2.客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。 
3、客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接
4、客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。 

服务器如何感知到客户端的断开：
判断socket是否已经断开的方法是使用非阻塞的select方式进行socket检查：
1，设置收到的socket为异步方式
2.使用select（）函数测试一个socket是否可读
3.如果select返回的值为1，但是使用recv函数读取的数据长度为0，那么说明该socket已经断开
4.如果recv返回值小于等于0时，客户端的连接已经断开，但是还需要判断errno是否等于EINTR，如果是，则说明recv函数是由于程序收到中断信号后返回的，socket连接应该还是正常，不应该close掉socket连接

对于阻塞socket的recv函数会有三种返回值：
1，接收到数据时返回
2.程序接收到信号时返回-1，errno=EINTR
3.socket出现问题时，返回-1，以及错误码

select是为单个线程使用多个socket而设计的，跟检测连接无关，如果只是检测一个socket的话，没有必要使用select。开了keepalive机能的话，每次调用recv或send时检查返回值，判断是否出错或为0.如果出错，再检查errno，看错误号表示连接断了或不存在就可以了

listen的backlog参数
int listen（int sockfd，int backlog）
内核为任何一个给定的监听套接字维护两个队列：
1.未完成连接队列，每个这样的SYN分节对应其中一项：已由某个客户端发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态
2.已完成连接队列，每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态
accept是为已连接队列中的连接建立本地的sockfd
监听socket如果有已完成的连接（刚从未完成连接到已完成连接队列），则监听套接字的sockfd是可读的，select多路复用下用到

0. accept()函数不参与三次握手，而只负责从已建立连接队列中取出一个连接和sockfd进行绑定；
1. backlog参数决定了未完成队列和已完成队列中连接数目之和的最大值(从内核角度看，是否这个和就是等于sock->recv_queue ？)；
2. accept()函数调用，会从已连接队列中取出一个“连接”(可以是一个描述连接的数据结构，listensocket->sock->recv_queue[sk_buff] ？ )，未完成队列和已完成队列中连接数目      之和将减少1；即accept将监听套接字对应的sock的接收队列中的已建立连接的sk_buff取下(从该sk_buff中可以获得对端主机的发送过来的tcp/ip数据包)
3. 监听套接字的已完成队列中的元素个数大于0，那么该套接字是可读的。
4. 当程序调用accept的时候(设置阻塞参数),那么判定该套接字是否可读，不可读则进入睡眠，直至已完成队列中的元素个数大于0(监听套接字可读)而唤起监听进程。

TCP和UDP的区别
TCP与UDP基本区别
  1.基于连接与无连接
  2.TCP要求系统资源较多，UDP较少； 
  3.UDP程序结构较简单 
  4.流模式（TCP）与数据报模式(UDP); 
  5.TCP保证数据正确性，UDP可能丢包 
  6.TCP保证数据顺序，UDP不保证 
UDP应用场景：
  1.面向数据报方式
  2.网络数据大多为短消息 
  3.拥有大量Client
  4.对数据安全性无特殊要求
  5.网络负担非常重，但对响应速度要求高
具体编程时的区别
   1.socket()的参数不同 
　　 2.UDP Server不需要调用listen和accept 
　　 3.UDP收发数据用sendto/recvfrom函数 
　　 4.TCP：地址信息在connect/accept时确定 
　　 5.UDP：在sendto/recvfrom函数中每次均 需指定地址信息 
　　 6.UDP：shutdown函数无效
基于上述不同，UDP和TCP编程步骤也有些不同，如下：

TCP: 
TCP编程的服务器端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt(); * 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
　　4、开启监听，用函数listen()； 
　　5、接收客户端上来的连接，用函数accept()； 
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接； 
　　8、关闭监听； 

TCP编程的客户端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
　　4、设置要连接的对方的IP地址和端口等属性； 
　　5、连接服务器，用函数connect()； 
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接；

UDP:
与之对应的UDP编程步骤要简单许多，分别如下： 
　　UDP编程的服务器端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
　　4、循环接收数据，用函数recvfrom(); 
　　5、关闭网络连接； 

UDP编程的客户端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
　　4、设置对方的IP地址和端口等属性; 
　　5、发送数据，用函数sendto(); 
　　6、关闭网络连接；
TCP与UDP区别总结：
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

连续发送1 2 3 4 5五个包，2 3 4在过程中丢失，此时发包端收到的ack回复是什么情况？
ack第一个和第五个包？？？这点存在疑问
