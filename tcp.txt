三次握手：
第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
握手过程中会传输两端的窗口大小和MSS大小。
MSS是TCP允许发送的最大数据部分的长度。
MTU是1500字节，去掉IP头20字节和TCP头20字节之后剩下1460字节，就是默认情况下MSS的大小。MSS只会在syn报文中携带。连接的MSS，是服务端和客户端两个MSS中最小的那一个。
当实际发送的数据大小超过MSS就会出现TCP分块。
TCP连接的起始序列号是随机生成的。

为什么要采用三次握手，两次不行吗？
如果改成两次握手，即客户端发送SYN，服务器发送SYN+ACK，在服务器发送SYN+ACK之后无法知道客户端是否正确处理了SYN+ACK（可以是没收到，也可以是客户端程序异常没正确处理），
服务器无法感知这种异常，都会默认连结已建立。

未连接队列
在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。
这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。

四次挥手：
客户端和服务端均可以发起
1、客户端发起、请求断开链接。发送报文FIN=1，当FIN=1的时候，表明此报文的发送方已经完成了数据的发送，没有新的数据要传送，并要求释放链接。客户端进入FIN-WAIT-1状态。
2、服务器收到客户端的请求断开链接的报文之后，返回确认信息。ACK=1，服务器进入CLOSE-WAIT状态。此时客户端不能给服务器发送信息报文，只能接收。
3、当服务器也没有了可以传的信息之后，给客户端发送请求结束的报文。FIN=1，ACK=1，服务器进入LAST-ACK状态。
4、客户端接收到FIN=1的报文之后，返回确认报文，ACK=1，发送完毕之后，客户端进入等待状态，等待两个MSL(最大报文生存周期)。链接关闭。

注意：为什么要等两个MSL
1.客户端最后一个确认收到的ACK=1的报文如果在传输的过程中丢失，服务端没有收到确认报文，就会超时重传，重新发送FIN=1的报文，如果不等两个时间周期，
重新发的FIN=1的报文客户端不会收到。
2.防止前面提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK后，再经过两个时间周期，就可以使本连接持续的时间内所产生的所有报文都
从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

为什么建立连接协议是三次握手，而关闭连接却是四次？
因为服务端的LISTEN状态下的socket当收到SYN报文的连接请求后，可以吧ACK和SYN放在同一个报文来发送。但关闭连接时，当收到对方的FIN报文
通知时，仅仅表示对方没有数据发送给你了，但是未必你的所有数据都发送给对方了，所以可能未必会马上关闭SOCKET，可能还要发送一些数据给对方
之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以关闭连接的时候FIN和ACK通常都是分开发送的。

TIME_WAIT和CLOSE_WAIT
TIME_WAIT是主动关闭连接产生的，目的是等待2MSL防止最后一个ACK丢包。
CLOSE_WAIT是被动关闭连接产生的，被动关闭连接的一方在处理完数据之后发送FIN报文关闭连接。
如果服务器出现大量CLOSE_WAIT的连接，说明服务器在收到对端的FIN报文并回复ACK之后没有调用close()，这种一般就是代码逻辑存在问题。比如IO线程被意外阻塞，业务线程一直占用CPU导致IO线程没有办法调度，或者IO线程没有调用close()等。

accept发生在三次握手的哪个阶段？
三次握手完成后，客户端和服务器建立了tcp连接。这时可以调用accept函数获得此连接。

滑动窗口
TCP协议传输中有四类报文：
1、已发送且对端已确认的报文
2、已发送且对端没有确认的报文
3、未发送且对端允许发送的报文
4、未发送且对端不允许发送的报文
其中2、3就是存在于滑动窗口内的报文。
滑动窗口的大小就是对端socket接受缓冲区的大小。TCP三次握手过程中通信双方会通知对方窗口的大小。
通信过程中则会实时通知对方自己当前可用的窗口大小。

RENO拥塞控制算法
拥塞窗口、慢启动、拥塞避免、快恢复、快重传
拥塞窗口是指发送端在一个RTT内最多可以发送的报文段数，拥塞窗口的单位是报文段。
慢启动，拥塞窗口设定为一个MSS大小，在达到慢启动门限之前，每经过一个传输轮次，拥塞窗口指数扩大，扩大的单位的是MSS的大小。
所谓传输轮次，就是把拥塞窗口所允许发送的报文全部发送出去，并受到了对已发送数据最后一个字节的确认。

拥塞避免，在达到慢启动门限(大多数TCP的实现，门限大小设定为65535)之后，每经过一个传输轮次，拥塞窗口加1个MSS大小，拥塞窗口按线性规律增长。
当发送方超时定时器已经触发且仍未受到对方确认，或者连续收到对方3个重复确认，则判定出现拥塞。
当出现拥塞的时候，将慢启动门限设置为当前窗口大小的1/2，并重新开始慢启动算法，将拥塞窗口设置为1，重新开始增长。

快恢复，当慢启动门限设置为当前窗口大小的1/2时，并不按照慢启动算法，将拥塞窗口设置为1，而是设置为慢启动门限的大小。并开始执行拥塞避免算法，窗口大小线性增长。

快重传，接收端在收到一个乱序报文之后立刻发送ack，而不需要等到自己发送数据的时候再捎带ack。发送方连续收到3个重复ack就立即重传对方尚未收到的数据，不会等待重传定时器超时。

BIC拥塞控制算法
拥塞控制算法的本质是在搜索一个最佳的窗口值，上面RENO采用了类似遍历的方式。而BIC算法的思想则是采用二分查找的方式。
当出现丢包的时候，说明最佳窗口值比当前的窗口值小，就把当前值设置为max_win。把乘法减小后的值设置为min_win(类似于RENO的快恢复机制)。在这个区间内使用二分法查找最佳窗口。
收到ack的时候，将窗口设置到max_win和min_win的中点。再次收到ack的时候min_win等于当前的窗口大小，然后继续找max_win和min_win的中点，不断逼近max_win。
如果实际窗口已经无限接近max_win，说明最大带宽已经不止max_win了。那么就根据刚刚逼近max_win的路线，倒序对称增长，直到找到新的max_win。这个阶段称之为max_probe。
BIC算法和RENO算法相似点在于窗口的变动都依赖于ack，也就是说算法的结果和效果与RTT相关。

CUBIC拥塞控制算法
是在BIC算法的基础上进行改进，改进了BIC在低速网络中增长过快的不足，也简化了算法。通过一个三次函数来控制窗口的增长。
可以通过参数来控制从起始窗口到最大窗口的时间。
CUBIC算法可以分为稳定阶段(即到达最大窗口的时间，这个阶段没有丢包)，探测阶段(寻找新的最大窗口的阶段)和收敛阶段(即出现了丢包，从而减少当前窗口大小的阶段)

BBR拥塞控制算法
上面的拥塞控制算法都是基于丢包的，但是丢包的原因可能是拥塞导致的也可能是错误导致的。而传统的拥塞控制算法默认丢包一定是由于拥塞导致的。
但是在当前高速(大带宽)网络和无线网络的情况下，错误导致的丢包是不能忽略的。如果统一将丢包当成拥塞来处理，会导致无法有效的利用网络带宽。
而且网络设备一般来说都会存在缓冲区，传统的拥塞控制是倾向于填满缓冲区。当网络出现拥塞同时缓冲区又设置的很大的话，需要很长时间才能清空缓冲区里的数据。会造成很大的网络延迟。
BBR算法的观点为：在网络数据包没有达到最大带宽的情况下，发送速率的增加不会导致RTT的变化。当发送速率刚好等于网络最大带宽的时候，网络达到最优点。
当达到最优点之后继续增加发送速率，实际的数据传输速度不会变化，而会开始占用缓存，当缓存被占满的时候就会出现丢包。
因此BBR算法并不考虑丢包，而是要找到网络最优工作点(最大的带宽和最小的RTT)。
测量最大带宽需要将链路填满，缓存中有数据，此时RTT一定不是最小的。测量最小RTT则要保证缓存为空，链路的数据越少越好，此时带宽一定不是最大的。
BRR是交替测量最大带宽和最小RTT，有四个状态：启动、排空、带宽探测、时延探测。
1)当连接刚建立，BRR采用类似RENO慢启动的策略，指数增长发送速率。尽快占满链路。当有三次发现传输速率不再增加，说明链路已经占满了，开始进入排空阶段。
2)指数降低发送速率，相当于前面的逆过程，将之前占用的缓存排空。
3)完成上面两步，进入稳定状态之后，BBR通过改变发送速率来进行带宽探测。其实在启动阶段，BRR就已经得到了链路的最大带宽。后续的带宽探测是用来判断最大带宽是否发生了变化。
在带宽探测周期为8个RTT，在第一个RTT内增加发送速率为当前最大带宽的1.25倍。如果RTT没有变化，说明最大带宽增长了，在第二个RTT内将发送速率减小为最大带宽的0.75倍用于排空前一个RTT多发的包。接下来6个周期内用更新后的最大带宽发包。
如果RTT变大了，说明最大带宽没有变化。
4)BRR每过10s，如果估计RTT不变，则进行时延探测。BRR在探测过程中将发送窗口固定为4个包，然后维持至少200ms。
定义带宽时延积BDP=最大带宽*最小时延，而最终的拥塞窗口大小=BDP*窗口增益系数。

糊涂窗口、NAGLE算法、CORK算法、延迟ACK
糊涂窗口是滑动窗口机制的一种问题。如果接收端处理数据的能力比较慢，根据滑动窗口，发送端每次能发送的数据就很小。极端情况下，有效载荷就1个字节，其他数据都是TCP头部。
这样就会导致网络上传输着大量的小报文，效率低下。糊涂窗口只是小报文的原因之一。
NAGLE算法和CORE算法是发送端对于小报文的解决方案，而延迟ACK是接收端对于小报文的解决方案。

NAGLE算法，TCP连接建立的时候双方会确认该连接的MSS（TCP数据包每次能够传输最大的数据分段）。
该算法的基本是任意时刻，最多只能有一个未被确认的“小段”（小于MSS的数据块）。
1、如果数据包长度达到MSS，则允许发送。
2、如果数据包包含FIN，则允许发送。
3、设置了TCP_NODELAY（禁用NAGLE算法），则允许发送。
4、未设置TCP_CORK选项，所有发出去的小段均被确认，则允许发送。
5、上述条件都未满足，但发生了ACK超时，则立即发送。

TCP_CORK选项
该选项的作用是让内核将小数据包拼接成一个大数据包再发送出去。或者在一定时间内，仍未拼成一个大数据包，也发送。
这个选项对于那种发送小包，且发送间隔比较长的应用程序无效，反而会降低发送的实时性。

Nagle算法与CORK算法区别
Nagle算法的初衷：避免发送大量的小包，防止小包泛滥于网络，理想情况下，对于一个TCP连接而言，网络上每次只能一个小包存在。它更多的是端到端意义上的优化。
CORK算法的初衷：提高网络利用率，理想情况下，完全避免发送小包，仅仅发送满包以及不得不发的小包。

延迟ACK很好理解，就是接收端收到数据之后不会马上回复ACK，而是等待一段时间，通过ACK报文确认尽可能多的数据。但是需要注意的是延迟ACK和NAGLE算法是有冲突的。两者同时使用可能会使TCP连接进入一种僵持状态。
发送端不发数据，接收端也不确认，最终导致数据传输的大量延迟。

TCP和UDP的区别
协议层面：
1、TCP有连接，UDP无连接。
2、TCP可靠，UDP不可靠。
3、TCP流传输，数据有序。UDP包传输，数据无序。
4、TCP有拥塞控制，UDP没有。
5、TCP占用的系统资源多于UDP，TCP的效率比UDP低。

代码层面：
1、TCP和UDP的socket参数不同。
2、TCP服务端有accept，客户端有connect。UDP客户端可以connect，然后用send/recv收发数据。也可以不用connect，用sendto、recvfrom收发数据。
3、TCP发送接收用的send、recv。UDP发送接收用的sendto、recvfrom。
TCP客户端
创建socket、bind(可选)、connect、send/recv
TCP服务端
创建socket、bind、listen、accept、send/recv
UDP客户端
socket、bind(可选)、sendto
UDP服务端
socket、bind、recvfrom

