三次握手：
第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

为什么要采用三次握手，两次不行吗？
假定一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。这个报文
早已失效，但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么
只要B发出确认，新的连接就建立了。
由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据，B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就
这样白白浪费了。
采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。
//更简单的解释是：
如果改成两次握手，即客户端发送SYN，服务器发送SYN+ACK，在服务器发送SYN+ACK之后无法知道客户端是否正确处理了SYN+ACK（可以是没收到，也可以是客户端程序异常没正确处理），
服务器无法感知这种异常，都会默认连结已建立。

未连接队列
在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。
这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。

四次挥手：
客户端和服务端均可以发起
1、客户端发起、请求断开链接。发送报文FIN=1，当FIN=1的时候，表明此报文的发送方已经完成了数据的发送，没有新的数据要传送，并要求释放链接。客户端进入FIN-WAIT-1状态。
2、服务器收到客户端的请求断开链接的报文之后，返回确认信息。ACK=1，服务器进入CLOSE-WAIT状态。此时客户端不能给服务器发送信息报文，只能接收。
3、当服务器也没有了可以传的信息之后，给客户端发送请求结束的报文。FIN=1，ACK=1，服务器进入LAST-ACK状态。
4、客户端接收到FIN=1的报文之后，返回确认报文，ACK=1，发送完毕之后，客户端进入等待状态，等待两个时间周期。链接关闭。

注意：为什么要等两个时间周期
1.客户端最后一个确认收到的ACK=1的报文如果在传输的过程中丢失，服务端没有收到确认报文，就会超时重传，重新发送FIN=1的报文，如果不等两个时间周期，
重新发的FIN=1的报文客户端不会收到。
2.防止前面提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK后，再经过两个时间周期，就可以使本连接持续的时间内所产生的所有报文都
从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

为什么建立连接协议是三次握手，而关闭连接确是四次？
因为服务端的LISTEN状态下的socket当收到SYN报文的连接请求后，可以吧ACK和SYN放在同一个报文来发送。但关闭连接时，当收到对方的FIN报文
通知时，仅仅表示对方没有数据发送给你了，但是未必你的所有数据都发送给对方了，所以可能未必会马上关闭SOCKET，可能还要发送一些数据给对方
之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以关闭连接的时候FIN和ACK通常都是分开发送的。

accept发生在三次握手的哪个阶段？
三次握手完成后，客户端和服务器建立了tcp连接。这时可以调用accept函数获得此连接。

滑动窗口
TCP协议传输中有四类报文：
1、已发送且对端已确认的报文
2、已发送且对端没有确认的报文
3、未发送且对端允许发送的报文
4、未发送且对端不允许发送的报文
其中2、3就是存在于滑动窗口内的报文。
滑动窗口的大小就是对端socket接受缓冲区的大小。TCP三次握手过程中通信双方会通知对方窗口的大小。
通信过程中则会实时通知对方自己当前可用的窗口大小。

拥塞窗口、慢启动、拥塞避免、快恢复、快重传
拥塞窗口是指发送端在一个RTT内最多可以发送的报文段数，拥塞窗口的单位是报文段。
慢启动，即拥塞窗口从1开始启动，在达到慢启动门限之前，每经过一个传输轮次，拥塞窗口指数扩大。
拥塞避免，在达到慢启动门限之后，每经过一个传输轮次，拥塞窗口加1，拥塞窗口按线性规律缓慢增长。
所谓传输轮次，就是把拥塞窗口所允许发送的报文全部发送出去，并受到了对已发送数据最后一个字节的确认。
快恢复，当发送方超时定时器已经触发且仍未受到对方确认，或者连续受到对方3个重复确认，则判定出现拥塞。
将慢启动门限重新设置为当前拥塞窗口的1/2（不能小于2），并由此开始重新执行拥塞避免算法，拥塞窗口按线性规律缓慢增长。
快重传是指接收端在收到一个乱序报文之后立刻发送ack，而不需要等到自己发送数据的时候再捎带ack。

糊涂窗口、NAGLE算法、CORK算法、延迟ACK
糊涂窗口是滑动窗口机制的一种问题。如果接收端处理数据的能力比较慢，根据滑动窗口，发送端每次能发送的数据就很小。极端情况下，有效载荷就1个字节，其他数据都是TCP头部。
这样就会导致网络上传输着大量的小报文，效率低下。糊涂窗口只是小报文的原因之一。
NAGLE算法和CORE算法是发送端对于小报文的解决方案，而延迟ACK是接收端对于小报文的解决方案。

NAGLE算法，TCP连接建立的时候双方会确认该连接的MSS（TCP数据包每次能够传输最大的数据分段）。
该算法的基本是任意时刻，最多只能有一个未被确认的“小段”（小于MSS的数据块）。
1、如果数据包长度达到MSS，则允许发送。
2、如果数据包包含FIN，则允许发送。
3、设置了TCP_NODELAY（禁用NAGLE算法），则允许发送。
4、未设置TCP_CORK选项，所有发出去的小段均被确认，则允许发送。
5、上述条件都未满足，但发送了ACK超时，则立即发送。

TCP_CORK选项
该选项的作用是让内核将小数据包拼接成一个大数据包再发送出去。或者在一定时间内，仍未拼成一个大数据包，也发送。
这个选项对于那种发送小包，且发送间隔比较长的应用程序无效，反而会降低发送的事实性。

Nagle算法与CORK算法区别
Nagle算法的初衷：避免发送大量的小包，防止小包泛滥于网络，理想情况下，对于一个TCP连接而言，网络上每次只能一个小包存在。它更多的是端到端意义上的优化。
CORK算法的初衷：提高网络利用率，理想情况下，完全避免发送小包，仅仅发送满包以及不得不发的小包。

很多人都把Nagle算法的目的理解为“提高网络利用率”，事实上，Nagle算法所谓的“提高网络利用率”只是它的一个副作用(Side effect...)，Nagle算法的主旨在于“避免发送‘大量’的小包”。
Nagle算法并没有阻止发送小包，它只是阻止了发送大量的小包！诚然，发送大量的小包是降低了网络利用率，但是，发送少量必须发送的小包也是对网络利用率的降低，想彻底提高网络利用率，为嘛不直接阻止小包发送呢？
不管是大量小包还是少量小包，甚至一个小包也不让发送，这才是提高网络利用率的正解！是的，TCP_CORK就是做这个的。所以有人说，CORK选项是Nagle的增强，而实际上，它们是完全不同的两回事，初衷不同。
Nagle算法和CORK算法着眼点不一样，Nagle算法主要避免网络因为太多的小包（协议头的比例非常之大）而拥塞，而CORK算法则是为了提高网络的利用率，使得总体上协议头占用的比例尽可能的小。
如此看来这二者在避免发送小包上是一致的，在用户控制的层面上，Nagle算法完全不受用户socket的控制，你只能简单的设置TCP_NODELAY而禁用它，CORK算法同样也是通过设置或者清除TCP_CORK使能或者禁用之，
然而Nagle算法关心的是网络拥塞问题，只要所有的ACK回来则发包，而CORK算法却可以关心内容，在前后数据包发送间隔很短的前提下（很重要，否则内核会帮你将分散的包发出），即使你是分散发送多个小数据包，
你也可以通过使能CORK算法将这些内容拼接在一个包内，如果此时用Nagle算法的话，则可能做不到这一点。

延迟ACK很好理解，就是接收端收到数据之后不会马上回复ACK，而是等待一段时间，通过ACK报文确认尽可能多的数据。但是需要注意的是延迟ACK和NAGLE算法是有冲突的。两者同时使用可能会使TCP连接进入一种僵持状态。
发送端不发数据，接收端也不确认，最终导致数据传输的大量延迟。

TCP和UDP的区别
协议层面：
1、TCP有连接，UDP无连接。
2、TCP可靠，UDP不可靠。
3、TCP流传输，数据有序。UDP包传输，数据无序。
4、TCP有拥塞控制，UDP没有。

代码层面：
1、TCP和UDP的socket参数不同。
2、TCP服务端有accept，客户端有connect，UDP没有。
3、TCP发送接收用的send、recv。UDP发送接收用的sendto、recvfrom。
4、TCP占用系统资源多于UDP。

